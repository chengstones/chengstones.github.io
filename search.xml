<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Knapsack+</title>
    <url>/2021/04/02/Knapsack+/</url>
    <content><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><h4 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h4><h5 id="问题重述："><a href="#问题重述：" class="headerlink" title="问题重述："></a>问题重述：</h5><p>​        有N种物品和一个容量为$V$的背包。第i种物品最多有$M[i]$件可用，每件耗费的空间是$C[i]$，价值是$W[i]$。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<h5 id="问题思路："><a href="#问题思路：" class="headerlink" title="问题思路："></a>问题思路：</h5><p>解法同0-1背包问题，将$M[i]$件第$i$种物品拆开为$M[i]$件独立的一件，体积为$C[i]$，价值为$W[i]$</p>
<h5 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><p>$$<br>F(N，V)= max{ F(N-1，V)，F(N，V-C[N])+W[N] }<br>$$</p>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>仍然考虑二进制思想，把第i种物品换成若干个物品</p>
<p>其中使每件物品相关参数前都有一个系，这些系数分别为</p>
<p>$1，2，4，8……2^k $（使得$2^{(k+1)}-1$的物品个数超过$M[I]$）</p>
<p>这样可以将$N$种情况减少到$log N$种情况</p>
<h3 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h3><h4 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h4><h5 id="问题重述：-1"><a href="#问题重述：-1" class="headerlink" title="问题重述："></a>问题重述：</h5><blockquote>
<p>如果将前面1、2、3中的三种背包问题混合起来。也就是说，有的物品只可以取一次（0-1背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p>
</blockquote>
<h5 id="问题思路：-1"><a href="#问题思路：-1" class="headerlink" title="问题思路："></a>问题思路：</h5><p>考虑到0-1背包问题相比完全背包问题的代码只有一处不同</p>
<p>同时多重背包问题又可以通过二进制思想快速简化为0-1背包问题</p>
<p>可使用伪代码表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to N</span><br><span class="line">	if 第i件物品属于01背包</span><br><span class="line">		ZeroOnePack(F,C_i,W_i)</span><br><span class="line">	else if 第i件物品属于完全背包</span><br><span class="line">		CompletePack(F,C_i,W_i)</span><br><span class="line">	else if 第i件物品属于多重背包</span><br><span class="line">		MultiplePack(F,C_i,W_i,N_i)</span><br></pre></td></tr></table></figure>

<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>面对多重大问题可以分别分拆成小问题去解决：</p>
<p>对于混合背包问题本质上是0-1，完全背包和多重背包的结合</p>
<p>因此分别调用相关的算法去解决就行</p>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>0-1问题描绘决策问题的是否</p>
<p>当出现决策问题可以取遍整数的时候，可以采用二进制思路化成0-1决策问题</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2021/04/01/Knapsack/</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><h5 id="问题重述："><a href="#问题重述：" class="headerlink" title="问题重述："></a>问题重述：</h5><blockquote>
<p>有N件物品和一个容量为$V$的背包。放入第i件物品耗费的空间是$C[i]$，得到的价值是$W[i]$。求解将哪些物品装入背包可使价值总和最大。</p>
</blockquote>
<h5 id="问题思路："><a href="#问题思路：" class="headerlink" title="问题思路："></a>问题思路：</h5><p>任何一件物品可以选择放入或者不放入,考虑第$N$件物品：</p>
<ul>
<li>放入：问题简化为 $N-1$ 件物品，容量为$V-C[N]$， 得到的价值为$F(N-1，V-C[N])+W[N]$</li>
<li>不放入：问题简化为$N-1$件物品，容量为$V$，得到的价值为$F(N-1，V)$</li>
</ul>
<h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><p>$$<br>F(N，V)= max{F(N-1，V)，F(N-1，V-C[N])+W[N]}<br>$$</p>
<h5 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(x,y)</span> </span>&#123;<span class="keyword">return</span> (x&gt;y)? x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s[],<span class="keyword">int</span> v[],<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当没有物品可选或者可以存储的质量小于等于0时，显然能存储的物品价值为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[n]&gt;C) <span class="keyword">return</span> <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">// 当第N件物品质量超过所能容纳质量时，可以默认不选</span></span><br><span class="line">    <span class="comment">// 事实上这一步也可以忽略，可以包含在第三种情况中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C),<span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C-s[n])+v[n]);</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>倘若直接调用递归函数，会出现重复计算的问题</p>
<p>如果能出现一个数组来存储每次计算的结果时，可以减少重复计算的机会</p>
<p><strong>动态规划：</strong></p>
<h5 id="C-代码实现-1"><a href="#C-代码实现-1" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划解决0-1背包问题</span></span><br><span class="line"><span class="keyword">int</span> packarray[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// packarray[n][C] 用于储存前n件物品，容量为C的背包最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s[], <span class="keyword">int</span> v[], <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packarray[n][C]) <span class="keyword">return</span> packarray[n][C]; <span class="comment">//若已经计算过，则直接引用，避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[n]&gt;C) &#123;packarray[n][C] = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="keyword">return</span> packarray[n][C];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tem1 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">//不取第n件的情况</span></span><br><span class="line">        <span class="keyword">int</span> tem2 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C-s[n])+v[n]; <span class="comment">//取第n件的情况</span></span><br><span class="line">        <span class="keyword">if</span> (tem1&gt;tem2) packarray[n][C] = tem1;</span><br><span class="line">        <span class="keyword">else</span> packarray[n][C] = tem2;</span><br><span class="line">        <span class="keyword">return</span> packarray[n][C];  <span class="comment">//比较并赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化细节"><a href="#初始化细节" class="headerlink" title="初始化细节"></a>初始化细节</h3><p>如果要求背包刚好装满，则可以设$knapsack(0，a)(a != 0)$时取值无穷小，此时无法取到背包未满的解。</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h3><h5 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述:"></a>问题重述:</h5><blockquote>
<p>有N种物品和一个容量为V 的背包，每种物品都有<strong>无限件可用</strong>。放入第i种 物品的耗费的空间是C[i]，得到的价值是W[i]。求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
</blockquote>
<h5 id="问题思路：-1"><a href="#问题思路：-1" class="headerlink" title="问题思路："></a>问题思路：</h5><h6 id="思路1-1："><a href="#思路1-1：" class="headerlink" title="思路1-1："></a>思路1-1：</h6><p>（转换为0-1背包问题）</p>
<p>仍然以0-1背包问题进行理解，虽然每件物品有无限件可用，但是为保证物品数量不超过空间限制，至多可选第i件物品的个数为$[ C/C[i] ]$,因此问题变为了$[C/C[i]]$个i件物品的综合。</p>
<p>但可见当物品数目增多，容量增大时，该算法的复杂度会迅速<strong>膨胀</strong>。</p>
<h6 id="思路1-2："><a href="#思路1-2：" class="headerlink" title="思路1-2："></a>思路1-2：</h6><p>（更有效的转换为0-1背包问题）</p>
<p>把第i种物品拆成体积为$C[i]<em>2^k$、价值为$W[i]</em> 2^k$的若干件物品，其中k取遍满足$C[i]* 2^k ≤ V$ 的非负整数。</p>
<p><u>即采用二进制的思想，当选取两件相同物品时，等价于选取质量和价值均为原来两倍的物品</u>。</p>
<h6 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h6><p>一个简单的优化：若两件物品比较，其中一件物品价值更低，同时体积更大，那么可以将这一件物品舍去。</p>
<h6 id="思路3："><a href="#思路3：" class="headerlink" title="思路3："></a>思路3：</h6><p>当且仅当决定不继续选择这件物品时进行状态转移，否则持续当前状态</p>
<h5 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul>
<li><p>$$F(N，V)= max{ F(N-1，V - k * C[N]) + k * W[N] |0&lt;=k * C[N]&lt;=V }$$</p>
</li>
<li><p>$$F(N，V)= max{ F(N-1，V)，F(N，V-C[N])+W[N] }$$</p>
</li>
</ul>
<h5 id="C-代码实现-2"><a href="#C-代码实现-2" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划解决完全背包问题</span></span><br><span class="line"><span class="keyword">int</span> packarray[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// packarray[n][C] 用于储存前n件物品，容量为C的背包最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s[], <span class="keyword">int</span> v[], <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packarray[n][C]) <span class="keyword">return</span> packarray[n][C]; <span class="comment">//若已经计算过，则直接引用，避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[n]&gt;C) &#123;packarray[n][C] = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="keyword">return</span> packarray[n][C];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tem1 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">//不取第n件的情况</span></span><br><span class="line">        <span class="keyword">int</span> tem2 = <span class="built_in">knapsack</span>(n,s,v,C-s[n])+v[n]; <span class="comment">//取第n件的情况</span></span><br><span class="line">        <span class="keyword">if</span> (tem1&gt;tem2) packarray[n][C] = tem1;</span><br><span class="line">        <span class="keyword">else</span> packarray[n][C] = tem2;</span><br><span class="line">        <span class="keyword">return</span> packarray[n][C];  <span class="comment">//比较并赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h2><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>​         在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。</p>
<p>​        各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。</p>
<p>​         在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法</p>
</blockquote>
<h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><blockquote>
<p>​        动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>​         动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</p>
<p>​         若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy_base</title>
    <url>/2021/08/01/Numpy_base/</url>
    <content><![CDATA[<h2 id="理解Numpy"><a href="#理解Numpy" class="headerlink" title="理解Numpy"></a>理解Numpy</h2><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/numpy-logo-300.png" alt="img"></p>
<p>围绕数据类型ndarray 建立起的高级数据操作和数值计算的python库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li>类似matlab，数组的计算采用逐元素计算</li>
<li>底层实现基于C，因此计算速度远快于python本体</li>
</ul>
<h3 id="Ndarray"><a href="#Ndarray" class="headerlink" title="Ndarray"></a>Ndarray</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/ndarray.png" alt="img"></p>
<ul>
<li><p>存放同类型数据的多维数组</p>
</li>
<li><p>高级数组，比起数据集合（例如List）更像多维矩阵的结构</p>
</li>
<li><p>相对于python本体的动态储存结构，ndarrays一旦生成了，规模就不可改变</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">object</td>
<td align="left">数组或嵌套的数列</td>
</tr>
<tr>
<td align="left">dtype</td>
<td align="left">数组元素的数据类型，可选</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">对象是否需要复制，可选</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td align="left">subok</td>
<td align="left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td align="left">ndmin</td>
<td align="left">指定生成数组的最小维度</td>
</tr>
</tbody></table>
<h4 id="Ndarray生成函数"><a href="#Ndarray生成函数" class="headerlink" title="Ndarray生成函数"></a>Ndarray生成函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(x,dtype=<span class="built_in">float</span>)  <span class="comment">#将输入数据x转换为指定类型dtype的ndarray</span></span><br><span class="line">np.asarray(array)  <span class="comment">#将输入数据转换为一个新的（copy）的ndarray</span></span><br><span class="line">np.ones(N,dtype) </span><br><span class="line">np.ones_like(ndarray)  <span class="comment">#生成一个形状与参数数组完全相同的全1的ndarray</span></span><br><span class="line">np.zeros(N,dtype)</span><br><span class="line">np.zeros_like(ndarray)</span><br><span class="line">np.empty(N,dtype)  <span class="comment">#生成一个数据为初始化的指定类型为dtype的ndarray</span></span><br><span class="line">np.empty_like(ndarray)</span><br><span class="line">np.eye(N)</span><br><span class="line">np.identity(N)</span><br><span class="line">np.arange(begin,end,step)</span><br><span class="line">np.linspace(start,stop,num)</span><br><span class="line">np.logspace(start,stop,num)</span><br></pre></td></tr></table></figure>

<h2 id="Numpy-数据类型"><a href="#Numpy-数据类型" class="headerlink" title="Numpy 数据类型"></a>Numpy 数据类型</h2><h3 id="常用Numpy基本类型"><a href="#常用Numpy基本类型" class="headerlink" title="常用Numpy基本类型"></a>常用Numpy基本类型</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool_</td>
<td align="left">布尔型数据类型（True 或者 False）</td>
</tr>
<tr>
<td align="left">int_</td>
<td align="left">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr>
<td align="left">intc</td>
<td align="left">与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr>
<td align="left">intp</td>
<td align="left">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">字节（-128 to 127）</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">整数（-32768 to 32767）</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">整数（-2147483648 to 2147483647）</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">无符号整数（0 to 255）</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">无符号整数（0 to 65535）</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">无符号整数（0 to 4294967295）</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr>
<td align="left">float_</td>
<td align="left">float64 类型的简写</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td align="left">float64</td>
<td align="left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td align="left">complex_</td>
<td align="left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td align="left">complex64</td>
<td align="left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td align="left">complex128</td>
<td align="left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody></table>
<blockquote>
<p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p>
</blockquote>
<h3 id="数据类型对象（dtype）"><a href="#数据类型对象（dtype）" class="headerlink" title="数据类型对象（dtype）"></a>数据类型对象（dtype）</h3><h4 id="构造dtype对象"><a href="#构造dtype对象" class="headerlink" title="构造dtype对象"></a>构造dtype对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure>

<ul>
<li>object - 要转换为的数据类型对象</li>
<li>align - 如果为 true，填充字段使其类似 C 的结构体。</li>
<li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li>
</ul>
<h4 id="结构化数据类型"><a href="#结构化数据类型" class="headerlink" title="结构化数据类型"></a>结构化数据类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 首先创建结构化数据类型</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line"><span class="comment"># 将数据类型应用于 ndarray 对象</span></span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="comment"># 类型字段名可以用于存取实际的 age 列</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">&gt;&gt; [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; [(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.0</span>), (<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.0</span>)]</span><br></pre></td></tr></table></figure>

<p>每个内建类型都有一个唯一定义它的字符代码，如下：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">对应类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">b</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">(有符号) 整型</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">无符号整型 integer</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">浮点型</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">复数浮点型</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">timedelta（时间间隔）</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">datetime（日期时间）</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">(Python) 对象</td>
</tr>
<tr>
<td align="left">S, a</td>
<td align="left">(byte-)字符串</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">Unicode</td>
</tr>
<tr>
<td align="left">V</td>
<td align="left">原始数据 (void)</td>
</tr>
</tbody></table>
<blockquote>
<p>ndarray.reshape 通常返回的是非拷贝副本，即改变返回后数组的元素，原数组对应元素的值也会改变。</p>
</blockquote>
<h2 id="Numpy-切片和索引"><a href="#Numpy-切片和索引" class="headerlink" title="Numpy 切片和索引"></a>Numpy 切片和索引</h2><p>与python中list的切片和索引操作相似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line"><span class="built_in">print</span> (a[s])</span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line">&gt;&gt; [[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>切片还可以包括省略号 <strong>…</strong>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line">&gt;&gt; [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br><span class="line">&gt;&gt; [[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><h4 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h4><p>以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line">&gt;&gt; [<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>整体先用 [ ] 括起来表示索引</li>
<li>内部依次有ndim个序列，分别表示第i个axis</li>
<li>内部的每个序列的shape保持一致，最终索引的结果位于对应的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line">&gt;&gt; [[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">    [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line">    [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line">    [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]]) </span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]) </span><br><span class="line">y = x[rows,cols]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line">&gt;&gt; [[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line">    [ <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure>

<p>返回的结果是包含每个角元素的 ndarray 对象。</p>
<p>可以借助切片 <strong>:</strong> 或 <strong>…</strong> 与索引数组组合。如下面例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">c = a[<span class="number">1</span>:<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">d = a[...,<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">&gt;&gt; [[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">&gt;&gt; [[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">&gt;&gt; [[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>我们可以通过一个布尔数组来索引目标数组。</p>
<p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在我们会打印出大于 5 的元素  </span></span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x[x &gt;  <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大于 <span class="number">5</span> 的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<p>以下实例使用了 **~**（取补运算符）来过滤 NaN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([np.nan,  <span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span> (a[~np.isnan(a)])</span><br><span class="line">&gt;&gt; [ <span class="number">1.</span>   <span class="number">2.</span>   <span class="number">3.</span>   <span class="number">4.</span>   <span class="number">5.</span>]</span><br></pre></td></tr></table></figure>

<p>以下实例演示如何从数组中过滤掉非复数元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,  <span class="number">2</span>+<span class="number">6j</span>,  <span class="number">5</span>,  <span class="number">3.5</span>+<span class="number">5j</span>])  </span><br><span class="line"><span class="built_in">print</span> (a[np.iscomplex(a)])</span><br><span class="line">&gt;&gt; [<span class="number">2.0</span>+<span class="number">6.j</span>  <span class="number">3.5</span>+<span class="number">5.j</span>]</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<p>关于 np.ix_ 的具体使用：</p>
<p>如果 np.xi_ 中输入两个列表，则第一个列表存的是待提取元素的行标，第二个列表存的是待提取元素的列标，第一个列表中的每个元素都会遍历第二个列表中的每个值，构成新矩阵的一行元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])]</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line">[[x[<span class="number">1</span>,<span class="number">0</span>] x[<span class="number">1</span>,<span class="number">3</span>] x[<span class="number">1</span>,<span class="number">1</span>] x[<span class="number">1</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">5</span>,<span class="number">0</span>] x[<span class="number">5</span>,<span class="number">3</span>] x[<span class="number">5</span>,<span class="number">1</span>] x[<span class="number">5</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">7</span>,<span class="number">0</span>] x[<span class="number">7</span>,<span class="number">3</span>] x[<span class="number">7</span>,<span class="number">1</span>] x[<span class="number">7</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">2</span>,<span class="number">0</span>] x[<span class="number">2</span>,<span class="number">3</span>] x[<span class="number">2</span>,<span class="number">1</span>] x[<span class="number">2</span>,<span class="number">2</span>]]]</span><br></pre></td></tr></table></figure>

<p>关于普通索引和花式索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype = <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">0</span>)])</span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">#上述两种等价，本质上来说上面是下面的一种语法糖</span></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">0</span>),])</span><br><span class="line">&gt;&gt;[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">   [<span class="number">1</span> <span class="number">2</span>]]</span><br><span class="line"><span class="comment">#触发了花式缩影，默认为x[(0,0),:]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)])</span><br><span class="line">&gt;&gt;[<span class="number">1</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">&gt;&gt;[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">   [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"><span class="comment"># “:”不代表当前序列，而是对任意一种情况遍历所有序列，类似np.ix</span></span><br></pre></td></tr></table></figure>

<h2 id="Numpy广播（broadcast）"><a href="#Numpy广播（broadcast）" class="headerlink" title="Numpy广播（broadcast）"></a>Numpy广播（broadcast）</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) </span><br><span class="line">c = a * b </span><br><span class="line"><span class="built_in">print</span> (c)</span><br><span class="line">&gt;&gt; [ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure>

<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line">&gt;&gt;[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">   [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line">   [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">   [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p>
<p>可以广播的几种情况：</p>
<ol>
<li>两个数组各维度大小从后往前比对均一致</li>
<li>两个数组存在一些维度大小不相等时，有一个数组的该不相等维度大小为1</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Brain_Computer_Interface</title>
    <url>/2021/04/08/Brain_Computer_Interface/</url>
    <content><![CDATA[<p>参考书籍：<a href="https://book.douban.com/subject/27004902/">脑机接口导论</a></p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>任务：从侵入式电极所记录的原始信号中提取锋电位，提取用于分类的特征</p>
<h4 id="锋电位分类（侵入式方法）"><a href="#锋电位分类（侵入式方法）" class="headerlink" title="锋电位分类（侵入式方法）"></a>锋电位分类（侵入式方法）</h4><p>微电极阵列）</p>
<p>分离和提取每个记录电极采集的由单个神经元发出的锋电位</p>
<p>将单个神经元产生的锋点位从混合信号中提取出来</p>
<h6 id="峰值幅度"><a href="#峰值幅度" class="headerlink" title="峰值幅度"></a>峰值幅度</h6><h6 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h6><ol>
<li>小波</li>
<li>主成分分析</li>
</ol>
<h4 id="频域分析（非侵入式方法）"><a href="#频域分析（非侵入式方法）" class="headerlink" title="频域分析（非侵入式方法）"></a>频域分析（非侵入式方法）</h4><p>比如EEG 反映数千个神经元活动的信号，记录的信号能捕捉到大量神经元相互关联的活动，比如振荡活动|这些振荡活动的存在使得对信号进行频域分析特别有用</p>
<h6 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h6><p>将时变信号分解为一系列不同频率的正余弦波的加权和</p>
<blockquote>
<p>“陷波”滤波器能有效地去除特定频率的信号</p>
</blockquote>
<h6 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h6><p>BCI应用中，对信号的收集是在离散时间间隔对大脑信号进行采样的</p>
<p>对于离散采样型号，输入时间序列使之只在特定时间点有采样值，并转换为相应的傅里叶系数</p>
<h6 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h6><p>采用分治法，缩短运算时间</p>
<h6 id="频谱特征"><a href="#频谱特征" class="headerlink" title="频谱特征"></a>频谱特征</h6><p>从功率谱中提取特征：利用FFT计算功率谱，将特定频带的能量作为进一步分析的频谱特征</p>
<blockquote>
<p>实际运动和运动想象均能引起mu频带能量的减小，因此可以将mu频带的能量作为BCI的特征，以实现让受试者通过运动想象来移动光标</p>
<p>通过运动筛选找到受试者特有的频带</p>
<p>用机器学习算法从一堆频谱特征中自动选取适合的特征，以增加测试数据的分类正确率</p>
</blockquote>
<h5 id="小波分析"><a href="#小波分析" class="headerlink" title="小波分析"></a>小波分析</h5><p>傅里叶变换的“基函数”集是不同频率的正余弦波，时域范围为无限长，因此傅里叶变换用于表示有限的非周期函数或是有尖峰和不连续点的函数的效果比较差</p>
<p>同时傅里叶分析要求大脑信号是平稳信号（统计特性不随时间改变），其实不然，于是现实实验中采取的方法是短时窗内的傅里叶分析（短时傅里叶变换）但是其窗口宽度的选择是一个较大的问题：频率分辨率和时间分辨率的矛盾</p>
<p>小波分析：基函数选择有限长的称为小波的函数</p>
<blockquote>
<p>小波：又一个有限长的母小波通过伸缩和平移得到的</p>
</blockquote>
<h4 id="时域分析"><a href="#时域分析" class="headerlink" title="时域分析"></a>时域分析</h4><h5 id="Hjorth参数"><a href="#Hjorth参数" class="headerlink" title="Hjorth参数"></a>Hjorth参数</h5><p>三个参数：平均功率，均方根频率和均方根频率展开</p>
<blockquote>
<p>活动性，移动性和复杂性</p>
</blockquote>
<h5 id="分形维数"><a href="#分形维数" class="headerlink" title="分形维数"></a>分形维数</h5><p>如果一个信号表现出自相似性，则认为他是分形的</p>
<h5 id="自回归模型（AR）"><a href="#自回归模型（AR）" class="headerlink" title="自回归模型（AR）"></a>自回归模型（AR）</h5><p>假设：自然信号在时间上有相关联的趋势，能够利用之前的一些测量值来预测下一个测量值</p>
<h5 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h5><p>前面的时域方法不能明确地保持对在时域计算的信号特性的不确定性估计</p>
<blockquote>
<p>贝叶斯滤波技术提供了一种对信号特性及其不确定性进行估计的统计上合理的方案</p>
</blockquote>
<h5 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h5><p>贝叶斯滤波中最知名的算法，假设动态概率和测量概率均为线性高斯模型</p>
<h5 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h5><p>非线性非高斯过程</p>
<h4 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h4><p>将不同位置（通道）记录的大脑信号通过几种方式进行信号转换</p>
<ul>
<li>增强局部活动</li>
<li>减弱各通道的共有噪声</li>
<li>降低数据维度</li>
<li>识别隐含的源</li>
<li>最大程度区分不同类型的投影</li>
</ul>
<h4 id="伪迹去除技术"><a href="#伪迹去除技术" class="headerlink" title="伪迹去除技术"></a>伪迹去除技术</h4><h5 id="阈值法"><a href="#阈值法" class="headerlink" title="阈值法"></a>阈值法</h5><p>幅度或者其他特征值超过了预先设定的阈值，就直接舍去</p>
<h5 id="带阻和陷波滤波"><a href="#带阻和陷波滤波" class="headerlink" title="带阻和陷波滤波"></a>带阻和陷波滤波</h5><p>带阻滤波：使特定频带的分量衰减，而使其余分量通过</p>
<p>陷波滤波：如上</p>
<h5 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h5><p>假设伪迹对记录的大脑信号产生的影响是可叠加的</p>
<h5 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h5><p>寻找记录的大脑数据方差最大的方向，将新数据投影到特征向量上</p>
<blockquote>
<p>PCA已被证明去除EEG信号中的EOG伪迹是有用的，但是假如伪迹与信号不相干，采用PCA信号并不合适</p>
</blockquote>
<h5 id="独立分量分析"><a href="#独立分量分析" class="headerlink" title="独立分量分析"></a>独立分量分析</h5><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>将神经活动映射为一定的控制命令</p>
<p>监督学习和无监督学习</p>
<ul>
<li>监督学习：</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Bioinformatic</tag>
      </tags>
  </entry>
  <entry>
    <title>复变函数</title>
    <url>/2021/10/30/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Chapter-1-复数和复平面"><a href="#Chapter-1-复数和复平面" class="headerlink" title="Chapter 1 复数和复平面"></a>Chapter 1 复数和复平面</h2><span id="more"></span>
<h3 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h3><ol>
<li><p>复数域：实（虚）部 | 复数的代数结构 -&gt; 复数域 $\mathbb{C}$</p>
</li>
<li><p>$\mathbb{R}^2$ 复平面引入拓扑结构 -&gt; 欧式距离 | 构建双射 $\mathbb{C} \rightarrow \mathbb{R}^2$， 此时称为平面 $\mathbb{C}$</p>
</li>
<li><p>等价类：一向量经过平行移动关系得到的所有向量与原向量构成等价类</p>
</li>
<li><p>辅角 $Arg\ z = \theta + 2k\pi \ (k \in \mathbb{Z})$，辅角主值 $arg\ z = \theta \ (-\pi &lt; \theta &lt; \pi)$  </p>
</li>
<li><p>三角表达式： $z = |z|\ (\cos {Arg \ z}+i\sin{Arg\ z})$ | 共轭</p>
</li>
<li><p>三角不等式： $|z_1 + z_2| \leq |z_1|+|z_2| \qquad |z_1 - z_2| \geq ||z_1|-|z_2||$</p>
</li>
<li><p>重要不等式：$|Re\ z| \leq |z| \qquad |Im\ z| \leq |z|$ </p>
</li>
<li><p>重要等式：$|z| = \sqrt{z\overline{z}} \qquad x = \frac{z+\overline{z}}{2} \qquad y = \frac{z-\overline{z}}{i2}$</p>
</li>
<li><p>棣莫弗公式：$(\cos{\theta}+i\sin{\theta})^m = \cos{m\theta} + i\sin{m\theta}$</p>
<p>推导：$z^{\frac{1}{n}} = +\sqrt[n]{|z|}[\cos{\frac{1}{n}Arg\ z} + i\sin{\frac{1}{n}Arg \ z}]$</p>
</li>
<li><p>复球面和无穷大：$z \rightarrow (x’,y’,u’)$<br>$$<br>x’ = \frac{z+\overline{z}}{|z|^2+1} \qquad y’ = \frac{z-\overline{z}}{i(|z|^2+1)} \qquad u’ = \frac{|z|^2-1}{|z|^2+1}<br>$$</p>
</li>
</ol>
<h3 id="Section-2"><a href="#Section-2" class="headerlink" title="Section 2"></a>Section 2</h3><ol start="11">
<li>复平面的拓扑结构：距离 -&gt; 邻域 -&gt; 聚点、边界点 -&gt; 开集、闭集 -&gt; 紧集 </li>
<li>区域 &lt;- 连通性 若尔当曲线 &lt;- 简单闭合曲线</li>
<li>若尔当定理：若尔当闭合曲线可以将平面分成两个没有公共点的区域</li>
</ol>
]]></content>
      <categories>
        <category>Mathmetic</category>
      </categories>
      <tags>
        <tag>MA</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas</title>
    <url>/2021/08/02/Pandas/</url>
    <content><![CDATA[<h1 id="理解Pandas"><a href="#理解Pandas" class="headerlink" title="理解Pandas"></a>理解Pandas</h1><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas.png" alt="img"></p>
<p><strong>Pandas 是 Python 语言的一个扩展程序库，用于数据分析。</strong></p>
<p>Pandas 是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具。</p>
<p>Pandas 名字衍生自术语 “panel data”（面板数据）和 “Python data analysis”（Python 数据分析）。</p>
<p>Pandas 一个强大的分析结构化数据的工具集，基础是 Numpy（提供高性能的矩阵运算）。</p>
<p>Pandas 可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据。</p>
<p>Pandas 可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。</p>
<p>Pandas 广泛应用在学术、金融、统计学等各个数据分析领域。</p>
<h1 id="Pandas-数据结构"><a href="#Pandas-数据结构" class="headerlink" title="Pandas 数据结构"></a>Pandas 数据结构</h1><h2 id="Series"><a href="#Series" class="headerlink" title="$Series$"></a>$Series$</h2><p>$Series$ 构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, name, copy)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>data</strong>：一组数据(ndarray 类型)。</li>
<li><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</li>
<li><strong>dtype</strong>：数据类型，默认会自己判断。</li>
<li><strong>name</strong>：设置名称。</li>
<li><strong>copy</strong>：拷贝数据，默认为 False。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">myvar = pd.Series(a)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>在不指定索引值的时候默认为$0、1、2\cdots$​​序列，可以替换索引值</p>
<p>替换索引值后仍可以按照$0、1、2\cdots$序列来索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line">myvar = pd.Series(a, index = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="string">&quot;y&quot;</span>])</span><br><span class="line">&gt;&gt; Runoob</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="number">0</span>])</span><br><span class="line">&gt;&gt; Google</span><br></pre></td></tr></table></figure>

<p>我们也可以使用$ key/value $对象，类似字典来创建 $Series$：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="comment">#局部创建</span></span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<p>设置$Series$名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;RUNOOB-Series-TEST&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">Name: RUNOOB-Series-TEST, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="$DataFrame$"></a>$DataFrame$</h2><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas-DataStructure.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2021/04/df-dp.png" alt="img"></p>
<p>$DataFrame$构造方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure>

<p>Pandas DataFrame 是一个二维的数组结构，类似二维数组。</p>
<p>利用二维数组构造$DataFrame$​：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [[<span class="string">&#x27;Google&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Wiki&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Site&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">&gt;&gt;      Site   Age</span><br><span class="line"><span class="number">0</span>  Google  <span class="number">10.0</span></span><br><span class="line"><span class="number">1</span>  Runoob  <span class="number">12.0</span></span><br><span class="line"><span class="number">2</span>    Wiki  <span class="number">13.0</span></span><br></pre></td></tr></table></figure>

<p>利用字典构造$DataFrame$：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span> (df)</span><br><span class="line">&gt;&gt;   a   b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br></pre></td></tr></table></figure>

<p>没有对应的部分数据为 <strong>NaN</strong>。</p>
<p>Pandas 可以使用 <strong>loc</strong> 属性返回指定行的数据，如果没有设置索引，第一行索引为 <strong>0</strong>，第二行索引为 <strong>1</strong>，以此类推：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 返回第一行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">0</span>])</span><br><span class="line">&gt;&gt; calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: <span class="number">0</span>, dtype: int64</span><br><span class="line"><span class="comment"># 返回第二行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">1</span>])</span><br><span class="line">&gt;&gt; calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: int64</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>返回结果其实就是一个 Pandas Series 数据。</p>
</blockquote>
<p>也可以返回多行数据，使用 <strong>[[ … ]]</strong> 格式，**…** 为各行的索引，以逗号隔开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 返回第一行和第二行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">&gt;&gt;    calories  duration</span><br><span class="line"><span class="number">0</span>       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line"><span class="number">1</span>       <span class="number">380</span>        <span class="number">40</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>返回结果其实就是一个 Pandas DataFrame 数据</p>
</blockquote>
<p>我们可以指定索引值，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">&gt;&gt;       calories  duration</span><br><span class="line">day1       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">day2       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">day3       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&quot;day2&quot;</span>])</span><br><span class="line">calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: day2, dtype: int64</span><br></pre></td></tr></table></figure>

<h1 id="Pandas-CSV"><a href="#Pandas-CSV" class="headerlink" title="Pandas CSV"></a>Pandas CSV</h1><blockquote>
<p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p>
<p>CSV 是一种通用的、相对简单的文件格式，被用户、商业和科学广泛应用。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure>

<p><strong>to_string()</strong> 用于返回 DataFrame 类型的数据，如果不使用该函数，则输出结果为数据的前面 5 行和末尾 5 行，中间部分以 <strong>…</strong> 代替。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="head"><a href="#head" class="headerlink" title="- head()"></a>- head()</h4><blockquote>
<p>用于读取前面的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 <strong>NaN</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure>

<h4 id="tail"><a href="#tail" class="headerlink" title="- tail()"></a>- tail()</h4><blockquote>
<p>用于读取尾部的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 <strong>NaN</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h4 id="info"><a href="#info" class="headerlink" title="- info()"></a>- info()</h4><blockquote>
<p>info() 方法返回表格的一些基本信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.info())</span><br><span class="line">&gt;&gt;&lt; <span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">458</span> entries, <span class="number">0</span> to <span class="number">457</span>       </span><br><span class="line">Data columns (total <span class="number">9</span> columns): </span><br></pre></td></tr></table></figure>

<h3 id="Pandas-JSON"><a href="#Pandas-JSON" class="headerlink" title="Pandas JSON"></a>Pandas JSON</h3><h1 id="Pandas-数据清洗"><a href="#Pandas-数据清洗" class="headerlink" title="Pandas 数据清洗"></a>Pandas 数据清洗</h1><h3 id="dropna"><a href="#dropna" class="headerlink" title="- dropna()"></a>- dropna()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;any&#x27;</span>, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>axis：默认为 <strong>0</strong>，表示逢空值剔除整行，如果设置参数 <strong>axis＝1</strong> 表示逢空值去掉整列。</li>
<li>how：默认为 <strong>‘any’</strong> 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 <strong>how=’all’</strong> 一行（或列）都是 NA 才去掉这整行。</li>
<li>thresh：设置需要多少非空值的数据才可以保留下来的。</li>
<li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li>
<li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li>
</ul>
<h3 id="isnull"><a href="#isnull" class="headerlink" title="- isnull()"></a>- isnull()</h3><h3 id="fillna"><a href="#fillna" class="headerlink" title="- fillna()"></a>- fillna()</h3>]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>信息检索导论</title>
    <url>/2021/10/30/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<ul>
<li>Chapter 1-8 核心理论</li>
<li>Chapter 9-21 高级话题</li>
</ul>
<h2 id="Chapter-1-布尔检索"><a href="#Chapter-1-布尔检索" class="headerlink" title="Chapter 1 布尔检索"></a>Chapter 1 布尔检索</h2><ol>
<li><p>信息检索（IR）：</p>
<ul>
<li>大规模非结构化数据    </li>
<li>满足用户需求    </li>
<li>特定资料</li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>结构化 - 关系数据库</li>
<li>非结构化</li>
<li>半结构化 - 网页界面</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>给定类别体系（标注） </li>
<li>扩展 （类似于 ML 领域的分类概念）</li>
</ul>
</li>
<li><p>线性扫描（×）</p>
<ul>
<li>数据量</li>
<li>匹配方式灵活</li>
<li>打分排序</li>
</ul>
</li>
<li><p>词项-文档关联矩阵：布尔值</p>
</li>
<li><p>布尔值查询    逻辑连接词 </p>
</li>
<li><p>统计信息</p>
<ul>
<li><p><strong>正确率</strong>：返回的结果中真正和信息需求相关的文档所占的百分比</p>
</li>
<li><p><strong>召回率</strong>：所有和信息需求真正相关的文档中被检索系统返回的百分比</p>
</li>
</ul>
</li>
<li><p><strong>倒排索引</strong></p>
<ul>
<li><p>关联矩阵的稀疏性 -&gt; 倒排表</p>
</li>
<li><p>倒排记录：词项 -&gt; 文档编号<img src=".%5C%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA%5Cimage1.png" alt="image1"></p>
</li>
<li><p>构建倒排索引：收集文档 -&gt; 词条化 -&gt; 语言学处理 -&gt; 倒排索引</p>
</li>
<li><p>索引 — 倒排记录表 &amp;&amp; 词项词典</p>
</li>
</ul>
</li>
<li><p>布尔查询：对倒排记录表进行合并，例如：AND -&gt; 取交</p>
</li>
<li><p>倒排记录表</p>
<ul>
<li>单链表 -&gt; 文档的插入和更新</li>
<li>变长数组 -&gt; 节省指针内存消耗，访问速度快</li>
<li>-&gt; 定长数组的链表 </li>
</ul>
</li>
<li><p>合并 -&gt; 基于文档频率的启发式算法</p>
</li>
<li><p>基于基本布尔操作的扩展</p>
<ul>
<li><strong>排序检索模型</strong> </li>
</ul>
</li>
<li><p><strong>Future Key_Points</strong></p>
<ol>
<li>容忍错误 模糊查询</li>
<li>改善结构 支持复合查询</li>
<li>非二值 引入词项频率</li>
<li>评分</li>
</ol>
</li>
</ol>
<h2 id="Chapter-2-词项词典及倒排记录表"><a href="#Chapter-2-词项词典及倒排记录表" class="headerlink" title="Chapter 2 词项词典及倒排记录表"></a>Chapter 2 词项词典及倒排记录表</h2><ol>
<li>字符序列生成<ul>
<li>字节序列<ul>
<li>文档元信息</li>
<li>手动选择</li>
<li>基于机器学习分类</li>
</ul>
</li>
<li>文字系统 - 阿拉伯语（二维和混序）<ul>
<li>发音 -&gt; 线性化</li>
</ul>
</li>
</ul>
</li>
<li>文档单位选择：<ul>
<li>索引粒度 <ul>
<li>微型文档 — mini-document</li>
<li>权衡正确率和召回率</li>
</ul>
</li>
</ul>
</li>
<li>词条化<ul>
<li>字符序列 -&gt; 子序列</li>
<li>去掉特殊字符 -&gt; 拆分策略</li>
</ul>
</li>
<li>分词：最大匹配法和基于机器学习序列模型</li>
<li>停用词：常见词 | 与用户需求匹配的价值小</li>
<li>词项归一化<ul>
<li>将不完全一致的多个词条归纳成一个等价类 </li>
<li>词干还原<ul>
<li>去除单词两端词缀的启发式过程</li>
<li>包括去除派生词缀</li>
<li>Porter 算法</li>
</ul>
</li>
<li>词形归并<ul>
<li>利用词汇表和词形分析来去除屈折词缀</li>
<li>返回词的原形或词典中的词的过程</li>
</ul>
</li>
</ul>
</li>
<li>跳表（倒排记录表快速合并算法）<ul>
<li>启发式：在 $\sqrt{p}$ 处均匀设置跳表指针，$p$ 是倒排记录表长度</li>
</ul>
</li>
<li>含位置信息 &amp;&amp; 短语查询<ul>
<li>二元词索引 -&gt; </li>
<li>位置信息索引 -&gt;</li>
<li>后续词索引</li>
</ul>
</li>
</ol>
<h2 id="Chapter-3-词典及容错式检索"><a href="#Chapter-3-词典及容错式检索" class="headerlink" title="Chapter 3 词典及容错式检索"></a>Chapter 3 词典及容错式检索</h2><ol>
<li><p>词典搜索：哈希表、搜索树</p>
<ul>
<li>关键字 Num</li>
<li>关键字数目 动态 or 静态</li>
<li>访问</li>
</ul>
</li>
<li><p>哈希表 -&gt; 哈希函数映射 — 词汇表增长 （失效）</p>
</li>
<li><p>搜索树 -&gt; 预定义的排序方式</p>
</li>
<li><p>通配符 -&gt; 模糊查询 、 词干还原、  -&gt; B 树、反向 B 树</p>
<ol>
<li><p>轮排索引：支持词项旋转</p>
<p><img src=".%5C%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA%5Cimage2.png" alt="image2"></p>
</li>
<li><p>K-gram 索引</p>
</li>
</ol>
</li>
<li><p>拼写校正</p>
<ol>
<li>校正规范<ol>
<li>临近度的度量</li>
<li>更常见</li>
</ol>
</li>
<li>编辑距离</li>
<li>K-gram 索引</li>
<li>上下文敏感：保留 文档集 高频组合</li>
</ol>
</li>
<li><p>基于发音：soundex 算法</p>
</li>
</ol>
<h2 id="Chapter-4-索引构建"><a href="#Chapter-4-索引构建" class="headerlink" title="Chapter 4 索引构建"></a>Chapter 4 索引构建</h2><ol>
<li>硬件基础：<ol>
<li>访问内存 快于 访问磁盘</li>
<li>磁盘读写 寻道时间</li>
<li>操作系统以数据块为单位进行读写</li>
<li>磁盘 I/O 由系统总线处理 而不是 处理器</li>
<li>IR 系统服务器 内存 &gt;&gt; 系统内存</li>
</ol>
</li>
<li>基于块排序索引构建算法<ol>
<li>目的：基于磁盘的外部排序算法：减少随机寻道次数</li>
<li>步骤：分割文档集 -&gt; 排序词项ID - 文档ID 对 -&gt; 将临时排序结果存放到磁盘 -&gt; 合并</li>
</ol>
</li>
<li>内存式扫描索引构建算法<ol>
<li>目的：消除 词项 -&gt; ID 的数据结构</li>
<li>原理：每个块采用新字典</li>
</ol>
</li>
<li>分布式索引构建<ol>
<li>往往按照词项或文档进行分割后分布在多台计算机上</li>
<li>MapReduce架构：面向大规模计算机集群<ol>
<li>将计算任务划分成子任务快</li>
<li>使得每个工作节点在短时间内能够快速处理</li>
</ol>
</li>
</ol>
</li>
<li>动态索引构建<ol>
<li>考虑文档集动态变化</li>
</ol>
</li>
</ol>
<h2 id="Chapter-5-索引压缩"><a href="#Chapter-5-索引压缩" class="headerlink" title="Chapter 5 索引压缩"></a>Chapter 5 索引压缩</h2><p><em>Key word：无损压缩 | 词典和倒排索引 | 高速缓存 | 加快传输 | 统计特性| 词典 -&gt; 长串| 按块存储压缩 |变长字节编码和 γ 编码</em></p>
<ol>
<li>无损压缩 | 有损压缩</li>
<li>Heaps 定律 -&gt; 估计词项数目<ul>
<li>文档集大小和词汇量之间在对数空间存在线性关系</li>
<li>两点假设：文档数目 ++ 词汇量++ 且不收敛；大规模文档集 词汇量 极大</li>
</ul>
</li>
<li>Zipf 定律 -&gt; 建模词项分布<ul>
<li>如果 t1 是文档集中的出现最多的词项，t2 是文档集中的出现第二多的词项，依此类推，那么，<br>排名第 i 多的词项的文档集频率 cfi与 1/i 成正比</li>
</ul>
</li>
<li>词典压缩<ul>
<li>目的：将词典放入内存</li>
<li>方法：<ul>
<li>将词典看作单一字符串 -&gt; 定长数组 -&gt; 指针</li>
<li>按块储存 -&gt; 保留第一个词项指针 额外字节保存词项长度 -&gt; 减少词项指针个数</li>
<li>前端编码 -&gt; 公共前缀</li>
<li>最小完美哈希 -&gt; 静态</li>
</ul>
</li>
<li><img src=".%5C%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA%5Cimage3.png" alt="image3"></li>
</ul>
</li>
<li>倒排记录表压缩<ul>
<li>原理：高频词出现的文档 ID 序列值之间相差不大</li>
<li>可变字节码</li>
<li>γ 编码</li>
</ul>
</li>
</ol>
<h2 id="Chapter-6-文档评分、词项权重计算及向量空间模型"><a href="#Chapter-6-文档评分、词项权重计算及向量空间模型" class="headerlink" title="Chapter 6 文档评分、词项权重计算及向量空间模型"></a>Chapter 6 文档评分、词项权重计算及向量空间模型</h2><p><em>Key word：评分和排序 | 参数化索引和域索引 | 词项权重 | 向量空间法 | 向量空间法的变形</em></p>
<ol>
<li>结构信息，元数据（metadata），字段（field）</li>
<li>域加权评分 -&gt; 排序式布尔检索</li>
<li>权重学习</li>
</ol>
<h2 id="Chapter-7-一个完整搜索系统中的评分计算"><a href="#Chapter-7-一个完整搜索系统中的评分计算" class="headerlink" title="Chapter 7 一个完整搜索系统中的评分计算"></a>Chapter 7 一个完整搜索系统中的评分计算</h2><p><em>Key word：启发式策略 | 非精确排序 | 其他评分因子 | 部件 | 启发</em></p>
<ol>
<li>快速评分和排序<ul>
<li>考虑相对得分 而不是 绝对得分</li>
<li>筛除 idf 值较高的词项对应的倒排记录表</li>
<li>胜者表</li>
<li>静态得分和排序</li>
<li>影响度排序</li>
<li>簇剪枝</li>
</ul>
</li>
<li>信息检索系统组成<ul>
<li>层次型索引</li>
<li>查询词项的邻近性</li>
</ul>
</li>
<li> 向量空间模型对查询操作的支持</li>
</ol>
<h2 id="Chapter-8-信息检索的评价"><a href="#Chapter-8-信息检索的评价" class="headerlink" title="Chapter 8 信息检索的评价"></a>Chapter 8 信息检索的评价</h2><p><em>Key word：评价指标 | 标准测试集 | 形式化评价方法 | 用户效用 | 其他质量检索结果度量的计数</em></p>
<ol>
<li>常规测试方法<ul>
<li>文档集，信息需求，相关性判定结果</li>
<li>二值</li>
</ul>
</li>
<li>标准测试集</li>
<li>无序检索结果集合评价<ul>
<li>正确率</li>
<li>召回率</li>
<li>平衡 F 值</li>
</ul>
</li>
<li>有序检索结果集合评价</li>
<li>相关性判定</li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学</title>
    <url>/2021/10/30/%E6%8B%93%E6%89%91%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><span id="more"></span>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>一笔画问题和七桥问题</li>
<li>地图着色问题  -&gt; 问题与度量无关（距离，面积），而与区域邻接关系有关</li>
</ul>
<h3 id="Euler-多面体定理"><a href="#Euler-多面体定理" class="headerlink" title="Euler 多面体定理"></a>Euler 多面体定理</h3><p>凸多面体的面数 $f$ 、棱数 $l$ 和顶点数 $v$ 满足 Euler 公式<br>拓展：$f - l + v$ 由曲面本身决定，这个数称为 Euler 数</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>集合论</li>
<li>映射</li>
<li>笛卡尔积</li>
<li>等价关系</li>
</ul>
<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="拓扑空间"><a href="#拓扑空间" class="headerlink" title="拓扑空间"></a>拓扑空间</h3><ol>
<li><p>函数连续性的三种描述方法</p>
</li>
<li><p>拓扑空间的定义 -&gt; 拓扑公理：子集族 -&gt; i.全集和空集 ii.任意并 iii.有限交</p>
<blockquote>
<p>紧空间保证开集开性：任意并，有限交；保证闭集闭性：任意交，有限并</p>
</blockquote>
</li>
<li><p>离散拓扑和平凡拓扑</p>
</li>
<li><p>余有限拓扑、余可数拓扑和欧式拓扑</p>
</li>
</ol>
<h3 id="度量拓扑"><a href="#度量拓扑" class="headerlink" title="度量拓扑"></a>度量拓扑</h3><ol start="5">
<li>度量空间 -&gt; 度量d -&gt; 正定性、对称性和三角不等式</li>
<li>赋范空间 -&gt; 范数 -&gt; 正定性、齐次性和三角不等式 -&gt; 线性空间 （线性性）-&gt; 线性赋范空间 </li>
<li>引理 -&gt; 任意两个球形领域的交集是若干球形邻域的并集<ul>
<li>考虑该交集合内所有点都是内点，满足两个球的内点性质，取小距离作为半径，该球完全位于集合内，得证</li>
</ul>
</li>
<li>命题：考虑子集族（若干球形邻域的并集）是 X 上的一个拓扑<ul>
<li>证明：公理(1)(2)显然，考虑公理(3)，由引理(7) 显然，得证</li>
<li>该子集族称为由度量 d 决定的度量拓扑</li>
</ul>
</li>
</ol>
<h3 id="拓扑空间基本概念"><a href="#拓扑空间基本概念" class="headerlink" title="拓扑空间基本概念"></a>拓扑空间基本概念</h3><ol start="9">
<li>闭集 -&gt; 开集的余集<ul>
<li>全集和空集</li>
<li>任意交</li>
<li>有限并  -&gt; 由拓扑公理的 De morgan 定律推导</li>
</ul>
</li>
<li>邻域，内点，内部 </li>
</ol>
<ul>
<li>$x \in A$  -&gt; x 是 A 的内点， A 是 x 的邻域， A 的所有内点为 A 的内部</li>
<li>A 是 B 子集 -&gt; A 的内部 是 B 的内部 的子集</li>
<li>A 等于 A 的内部 &lt;-&gt; A 是开集 </li>
</ul>
<ol start="11">
<li>聚点，闭包</li>
</ol>
]]></content>
      <categories>
        <category>Mathmetic</category>
      </categories>
      <tags>
        <tag>MA</tag>
      </tags>
  </entry>
</search>
