<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Brain_Computer_Interface</title>
    <url>/2021/04/08/Brain_Computer_Interface/</url>
    <content><![CDATA[<p>参考书籍：<a href="https://book.douban.com/subject/27004902/">脑机接口导论</a></p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>任务：从侵入式电极所记录的原始信号中提取锋电位，提取用于分类的特征</p>
<h4 id="锋电位分类（侵入式方法）"><a href="#锋电位分类（侵入式方法）" class="headerlink" title="锋电位分类（侵入式方法）"></a>锋电位分类（侵入式方法）</h4><p>微电极阵列）</p>
<p>分离和提取每个记录电极采集的由单个神经元发出的锋电位</p>
<p>将单个神经元产生的锋点位从混合信号中提取出来</p>
<h6 id="峰值幅度"><a href="#峰值幅度" class="headerlink" title="峰值幅度"></a>峰值幅度</h6><h6 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h6><ol>
<li>小波</li>
<li>主成分分析</li>
</ol>
<h4 id="频域分析（非侵入式方法）"><a href="#频域分析（非侵入式方法）" class="headerlink" title="频域分析（非侵入式方法）"></a>频域分析（非侵入式方法）</h4><p>比如EEG 反映数千个神经元活动的信号，记录的信号能捕捉到大量神经元相互关联的活动，比如振荡活动|这些振荡活动的存在使得对信号进行频域分析特别有用</p>
<h6 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h6><p>将时变信号分解为一系列不同频率的正余弦波的加权和</p>
<blockquote>
<p>“陷波”滤波器能有效地去除特定频率的信号</p>
</blockquote>
<h6 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h6><p>BCI应用中，对信号的收集是在离散时间间隔对大脑信号进行采样的</p>
<p>对于离散采样型号，输入时间序列使之只在特定时间点有采样值，并转换为相应的傅里叶系数</p>
<h6 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h6><p>采用分治法，缩短运算时间</p>
<h6 id="频谱特征"><a href="#频谱特征" class="headerlink" title="频谱特征"></a>频谱特征</h6><p>从功率谱中提取特征：利用FFT计算功率谱，将特定频带的能量作为进一步分析的频谱特征</p>
<blockquote>
<p>实际运动和运动想象均能引起mu频带能量的减小，因此可以将mu频带的能量作为BCI的特征，以实现让受试者通过运动想象来移动光标</p>
<p>通过运动筛选找到受试者特有的频带</p>
<p>用机器学习算法从一堆频谱特征中自动选取适合的特征，以增加测试数据的分类正确率</p>
</blockquote>
<h5 id="小波分析"><a href="#小波分析" class="headerlink" title="小波分析"></a>小波分析</h5><p>傅里叶变换的“基函数”集是不同频率的正余弦波，时域范围为无限长，因此傅里叶变换用于表示有限的非周期函数或是有尖峰和不连续点的函数的效果比较差</p>
<p>同时傅里叶分析要求大脑信号是平稳信号（统计特性不随时间改变），其实不然，于是现实实验中采取的方法是短时窗内的傅里叶分析（短时傅里叶变换）但是其窗口宽度的选择是一个较大的问题：频率分辨率和时间分辨率的矛盾</p>
<p>小波分析：基函数选择有限长的称为小波的函数</p>
<blockquote>
<p>小波：又一个有限长的母小波通过伸缩和平移得到的</p>
</blockquote>
<h4 id="时域分析"><a href="#时域分析" class="headerlink" title="时域分析"></a>时域分析</h4><h5 id="Hjorth参数"><a href="#Hjorth参数" class="headerlink" title="Hjorth参数"></a>Hjorth参数</h5><p>三个参数：平均功率，均方根频率和均方根频率展开</p>
<blockquote>
<p>活动性，移动性和复杂性</p>
</blockquote>
<h5 id="分形维数"><a href="#分形维数" class="headerlink" title="分形维数"></a>分形维数</h5><p>如果一个信号表现出自相似性，则认为他是分形的</p>
<h5 id="自回归模型（AR）"><a href="#自回归模型（AR）" class="headerlink" title="自回归模型（AR）"></a>自回归模型（AR）</h5><p>假设：自然信号在时间上有相关联的趋势，能够利用之前的一些测量值来预测下一个测量值</p>
<h5 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h5><p>前面的时域方法不能明确地保持对在时域计算的信号特性的不确定性估计</p>
<blockquote>
<p>贝叶斯滤波技术提供了一种对信号特性及其不确定性进行估计的统计上合理的方案</p>
</blockquote>
<h5 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h5><p>贝叶斯滤波中最知名的算法，假设动态概率和测量概率均为线性高斯模型</p>
<h5 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h5><p>非线性非高斯过程</p>
<h4 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h4><p>将不同位置（通道）记录的大脑信号通过几种方式进行信号转换</p>
<ul>
<li>增强局部活动</li>
<li>减弱各通道的共有噪声</li>
<li>降低数据维度</li>
<li>识别隐含的源</li>
<li>最大程度区分不同类型的投影</li>
</ul>
<h4 id="伪迹去除技术"><a href="#伪迹去除技术" class="headerlink" title="伪迹去除技术"></a>伪迹去除技术</h4><h5 id="阈值法"><a href="#阈值法" class="headerlink" title="阈值法"></a>阈值法</h5><p>幅度或者其他特征值超过了预先设定的阈值，就直接舍去</p>
<h5 id="带阻和陷波滤波"><a href="#带阻和陷波滤波" class="headerlink" title="带阻和陷波滤波"></a>带阻和陷波滤波</h5><p>带阻滤波：使特定频带的分量衰减，而使其余分量通过</p>
<p>陷波滤波：如上</p>
<h5 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h5><p>假设伪迹对记录的大脑信号产生的影响是可叠加的</p>
<h5 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h5><p>寻找记录的大脑数据方差最大的方向，将新数据投影到特征向量上</p>
<blockquote>
<p>PCA已被证明去除EEG信号中的EOG伪迹是有用的，但是假如伪迹与信号不相干，采用PCA信号并不合适</p>
</blockquote>
<h5 id="独立分量分析"><a href="#独立分量分析" class="headerlink" title="独立分量分析"></a>独立分量分析</h5><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>将神经活动映射为一定的控制命令</p>
<p>监督学习和无监督学习</p>
<ul>
<li>监督学习：</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Bioinformatic</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2021/11/05/CSS/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStruct-Pseudocode</title>
    <url>/2021/11/02/DataStruct-Pseudocode/</url>
    <content><![CDATA[<p>仿cpp伪代码(Pseudocode)复现基本数据结构(DataStruct)<br><span id="more"></span></p>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表的基本运算</p>
<ul>
<li>建表 create()</li>
<li>清空 clear()</li>
<li>返回长度 length()</li>
<li>插入 insert(x, i)</li>
<li>删除 remove(i)</li>
<li>搜索 search(x)</li>
<li>访问 visit(i)</li>
<li>遍历 traverse()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;                    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">const</span> elemType &amp;x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> elemType &amp;x)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> elemType <span class="title">visit</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">list</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h3><ul>
<li>私有成员：当前长度 currentLength，数组大小 maxSize，数组头节点 data</li>
<li>私有函数：扩容数组 doubleSpace</li>
</ul>
<h4 id="扩容数组"><a href="#扩容数组" class="headerlink" title="扩容数组"></a>扩容数组</h4><ul>
<li>触发条件：当执行插入操作时，当前长度等于数组大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">声明临时数组保存数据;</span><br><span class="line">扩容;</span><br><span class="line">数组头节点 data 指向一个更大的数组;</span><br><span class="line"><span class="comment">// 挪动数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;currentLength;++i)&#123;</span><br><span class="line">    data[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">析构临时数组;</span><br></pre></td></tr></table></figure>
<h4 id="创建，返长，析构，清除，遍历"><a href="#创建，返长，析构，清除，遍历" class="headerlink" title="创建，返长，析构，清除，遍历"></a>创建，返长，析构，清除，遍历</h4><ul>
<li>创建申请一个定长的数组</li>
<li>返长直接返回当前长度</li>
<li>析构 delete []data</li>
<li>清除 使当前长度为 0</li>
<li>for 遍历</li>
</ul>
<h4 id="查找，访问"><a href="#查找，访问" class="headerlink" title="查找，访问"></a>查找，访问</h4><ul>
<li>遍历数组每一项，找到返回当前值，否则返回 -1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;currentLength;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(data[i] == 待查值) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接访问 data[i]</li>
</ul>
<h4 id="插入，清除"><a href="#插入，清除" class="headerlink" title="插入，清除"></a>插入，清除</h4><ul>
<li>插入采用逆序，从第 currentLength 开始， 每一项等于前一项</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(当前数组满了) 扩容;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(currentLength);j&gt;i;--j)&#123;</span><br><span class="line">    data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">data[i] = x;</span><br></pre></td></tr></table></figure>
<ul>
<li>清除采用正序，</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(i);j&lt;currentLength<span class="number">-1</span>;++j)&#123;</span><br><span class="line">    data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li>使用内置结构体 node，存有 data 和下一个 node 的指针</li>
<li>为了方便使用插入和清除操作，每个节点必须有前置节点，因此存在 head</li>
</ul>
<h5 id="创建，清除，析构，返长，遍历"><a href="#创建，清除，析构，返长，遍历" class="headerlink" title="创建，清除，析构，返长，遍历"></a>创建，清除，析构，返长，遍历</h5><ul>
<li>创建只需要声明头节点</li>
<li>清除从头节点的下一个节点开始，倘若该节点非空，则储存该节点析构，继续指向下一个节点<ul>
<li>最终头节点需要指向NULL</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">node* p = head -&gt; next;</span><br><span class="line">node* delp;</span><br><span class="line">head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    delp = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> delp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>析构调用清空函数，析构头节点</li>
<li>返长从头节点开始，如果下一个节点非空，则长度加1</li>
<li>遍历，从头节点的下一个节点开始，若节点非空，输出值，指向后置节点，循环</li>
</ul>
<h5 id="查找，访问-1"><a href="#查找，访问-1" class="headerlink" title="查找，访问"></a>查找，访问</h5><ul>
<li>查找从头节点的下一个节点开始，若节点非空，比较待查值：若相同，则输出该位置，否则位置+1；最终输出-1（说明没找到）</li>
<li>访问从头节点的下一个节点开始，for 循环</li>
</ul>
<h5 id="插入，清除-1"><a href="#插入，清除-1" class="headerlink" title="插入，清除"></a>插入，清除</h5><ul>
<li>插入从头节点开始，跳跃次数等于位置，使指针的后置节点修改为以指针的后置节点为参数的节点</li>
<li>清除从头节点开始，跳跃次数等于位置，储存其后置节点作为临时节点析构，讲后置节点改为其后置节点的后置节点</li>
</ul>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h1 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的基本运算</p>
<ul>
<li>建树 create()</li>
<li>清空 clear()</li>
<li>判空 isEmpty()</li>
<li>找根结点 Root()</li>
<li>找父节点 parent(x)</li>
<li>找子节点 child(x,i)</li>
<li>剪枝 remove(x,i)</li>
<li>遍历 traverse()<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Root</span><span class="params">(T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">parent</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">lchild</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">rchild</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delLeft</span><span class="params">(T x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delRight</span><span class="params">(T x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3>二叉树的基本运算</li>
<li>建树 create()</li>
<li>清空 clear()</li>
<li>判空 isEmpty()</li>
<li>找根节点 root()</li>
<li>找父节点 parent(x)</li>
<li>找左右孩子 lchild(x), rchild(x)</li>
<li>删除左右子树 delLeft(x), delRight(x)</li>
<li>遍历 traverse()</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>私有函数，仿前序遍历</li>
<li>参数 x-&gt; 寻找值;</li>
<li>参数 node* t -&gt; 需要开始查找的子树根结点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如果查找树为空树， <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">如果自己就是查找值， <span class="keyword">return</span> 自己</span><br><span class="line">否则</span><br><span class="line">查找左子树，得到 tmp，若 tmp 非 <span class="literal">NULL</span>， <span class="keyword">return</span> tmp</span><br><span class="line">否则，一定返回右子树 <span class="keyword">return</span> t-&gt;right </span><br></pre></td></tr></table></figure>
<h4 id="清空，析构，剪枝"><a href="#清空，析构，剪枝" class="headerlink" title="清空，析构，剪枝"></a>清空，析构，剪枝</h4></li>
<li>仿前序遍历：剪枝左子树，剪枝右子树，析构自己<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有函数 clear 参数 node* </span></span><br><span class="line"><span class="keyword">if</span> (左子树非空) clear 左子树;</span><br><span class="line"><span class="keyword">if</span> (右子树非空) clear 右子树;</span><br><span class="line"><span class="keyword">delete</span> 自己 -&gt; node;</span><br><span class="line">自己 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口函数 clear， 析构函数</span></span><br><span class="line">clear 根节点</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝</span></span><br><span class="line"><span class="keyword">if</span> (左子树空) <span class="keyword">return</span>; <span class="comment">// if (右子树空) return;</span></span><br><span class="line">clear tmp -&gt; left;   <span class="comment">// clear tmp -&gt; right</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul>
<li>先访问根结点，再访问左右子树</li>
<li>具体实现 -&gt; 递归 -&gt; 传入参数结点，实现对应功能</li>
<li>接口函数 包装 参数 void <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口函数 参数 void</span></span><br><span class="line">前序遍历根结点;</span><br><span class="line"><span class="comment">// 私有函数 参数 node*</span></span><br><span class="line"><span class="keyword">if</span>(结点空) <span class="keyword">return</span>;</span><br><span class="line">访问 当前结点;</span><br><span class="line">前序遍历左子树;</span><br><span class="line">前序遍历右子树;</span><br><span class="line"><span class="comment">// 中序后序遍历的实现方法几乎相同</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul>
<li>队列</li>
<li>规则：出列头结点，访问该节点，将左右子节点入队</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">    tmp = que.<span class="built_in">dequeue</span>();</span><br><span class="line">    访问节点 tmp;</span><br><span class="line">    <span class="keyword">if</span>(tmp 有左节点) 左节点入队;</span><br><span class="line">    <span class="keyword">if</span>(tmp 有右节点) 右节点入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><ul>
<li>面向控制台，队列</li>
<li>参数 截止参数 flag</li>
<li>规则：出列头结点，向控制台申请左右子节点，若非截止结点，则生成节点并入队</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">生成根节点，根节点入队</span><br><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">    tmp = que.<span class="built_in">dequeue</span>();</span><br><span class="line">    控制台获得两个子树的输入;</span><br><span class="line">    <span class="keyword">if</span>(左输入非截止) 生成父节点链接的新节点，节点入队;</span><br><span class="line">    <span class="keyword">if</span>(右输入非截止) 生成父节点链接的新节点，节点入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="非递归前序"><a href="#非递归前序" class="headerlink" title="非递归前序"></a>非递归前序</h4><ul>
<li>栈；参数 void</li>
<li>规则：出栈顶，访问该节点，入栈右左节点</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    访问该节点;</span><br><span class="line">    <span class="keyword">if</span>(该节点的右节点非空) 右节点入栈;</span><br><span class="line">    <span class="keyword">if</span>(该节点的左节点非空) 左节点入栈;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="非递归中序"><a href="#非递归中序" class="headerlink" title="非递归中序"></a>非递归中序</h4><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>抽象：访问 -&gt; 当访问子树只有一个节点时，即读取该数据；否则以相应规则继续 ‘访问’ 该子树</p>
<p>​    中序遍历相对于前序遍历，根节点不能直接访问，需要先访问它的左子树，然后才能访问根节点。假设以栈的方式储存任务节点，这里说明根节点需要出队两次才能被访问。第一次出栈后访问左节点，第二次出栈先访问自己，再访问右节点。</p>
<ul>
<li>新建结构体 StNode 封装之前的 Node 和出栈次数 TimesPop</li>
<li>规则：第一次出栈访问左子树，第二次出栈访问自己，访问右子树</li>
<li>起始条件：根节点入栈；终止条件：栈空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新节点 StNode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> Node*; TimesPop&#125;</span><br><span class="line"><span class="comment">// 中序遍历非递归实现</span></span><br><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(++current.TimesPop == <span class="number">1</span>)&#123;</span><br><span class="line">        当前节点重新入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有左子树) 左子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		访问该节点;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有右子树) 右子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归后序"><a href="#非递归后序" class="headerlink" title="非递归后序"></a>非递归后序</h4><h5 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h5><p>​    后序遍历在中序遍历的基础上继续展开，类比观察可知：后序遍历依次访问左子树，右子树和自己，因此考虑根节点第一次出栈后，将根节点入栈，再依次将右子树和左子树入栈即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新节点 StNode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> Node*; TimesPop&#125;</span><br><span class="line"><span class="comment">// 后序遍历非递归实现</span></span><br><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(++current.TimesPop == <span class="number">1</span>)&#123;</span><br><span class="line">        当前节点重新入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有右子树) 右子树入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有左子树) 左子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		访问该节点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与森林表示法"><a href="#树与森林表示法" class="headerlink" title="*树与森林表示法"></a>*树与森林表示法</h4><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="*哈夫曼树"></a>*哈夫曼树</h4><h5 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h5><ul>
<li>给定一个具有n个权值的节点的集合，构造出一片森林，其中每个森林都是只有树根节点的二叉树</li>
<li>执行 n-1 次循环操作，每个循环操作执行<ul>
<li>从当前森林选取权值最小和此最小的两棵树</li>
<li>以这两个数作为左右子树构建一棵新树，将新树的根节点加入森林</li>
<li>从原来的森林删除这两棵树</li>
</ul>
</li>
<li>由于创建树后这棵树不会被修改，因此可以采用静态方法：即在一开始为所有的数据声明空间</li>
</ul>
<h5 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h5><ul>
<li>初始化，申请 2n 数组，将数据储存在倒数n个空间内</li>
<li>循环 n-1 次，进行归并<ul>
<li>找到最小值，次小值及其对应位置</li>
<li>将最小值和次小值求和存入数组，将最小值和次小至位置存入左右子树，声明左右子树的父节点</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">申请 <span class="number">2</span>n 尺寸的大小;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size<span class="number">-1</span>);i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">    min1 = min2 = 极大值;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(i+<span class="number">1</span>);j&lt;length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(该节点权重低于最小值)&#123;</span><br><span class="line">            替换最小值为该值;</span><br><span class="line">            替换次小值为最小值;</span><br><span class="line">            替换最小值位置为该值位置;</span><br><span class="line">            替换次小值位置为最小值位置；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(该节点权重低于次小值)&#123;</span><br><span class="line">            替换次小值为该值;</span><br><span class="line">            替换次小值位置为该值位置;</span><br><span class="line">        &#125;</span><br><span class="line">    	elem[i] = 最小值 + 次小值;</span><br><span class="line">        elem[i] 的左右子树 = 最小值位置，次小值位置;</span><br><span class="line">        elem[i].parent = <span class="number">0</span>;</span><br><span class="line">        elem[最小值位置].parent = 父节点位置 i;</span><br><span class="line">        elem[次小值位置].parent = 父节点位置 i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="导出哈夫曼编码"><a href="#导出哈夫曼编码" class="headerlink" title="导出哈夫曼编码"></a>导出哈夫曼编码</h5><ul>
<li>从每个叶子节点出发，返回寻找父节点：若其为左子树，则添加前缀’0‘，否则添加前缀’1‘</li>
<li>遍历每一个叶子节点，按对应数组位输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);i&lt;length;++i)&#123;</span><br><span class="line">    result[i-size].data = result[i].data;</span><br><span class="line">    result[i-size].code = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">    p = elem[i].parent; s = i;</span></span><br><span class="line"><span class="string">   	while(p 非0)&#123;</span></span><br><span class="line"><span class="string">        if(p的左节点是s)</span></span><br><span class="line"><span class="string">            result[i-size].code 添加前缀 &#x27;</span><span class="number">1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> 添加前缀 <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s = p;</span><br><span class="line">        p = elem[p].parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表达式树"><a href="#表达式树" class="headerlink" title="*表达式树"></a>*表达式树</h4><p>二叉树计算一个算术表达式由两个组成：i. 将中缀表达式转换成一个二叉树  ii. 对二叉树进行后序遍历</p>
<h5 id="构建表达式树"><a href="#构建表达式树" class="headerlink" title="构建表达式树"></a>构建表达式树</h5><h6 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h6><p>类比中缀表达式转换为后缀表达式的算法，我们考虑使用两个栈：操作符栈和子树栈。当操作符栈出栈时，选取子树栈顶的两个元素进行运算，返回结果加入操作数栈。</p>
<ul>
<li>按顺序读入表达式中的每个字符；<ul>
<li>若读入数字，则构造节点，压入子树栈</li>
<li>读入操作符，与栈顶优先级比较，依次出栈所有优先级高于该操作符的元素。然后将读入的操作符压栈</li>
<li>读入左括号，压栈；读入右括号，持续出栈直至到左括号</li>
<li>左括号优先级最高</li>
</ul>
</li>
<li>当操作符栈出栈时，依次由子树栈弹出两个子树，分别作为运算符栈的右左子树；</li>
<li>初始操作：将#压入操作符栈；终止操作：读完所有运算符后，将所有操作符出栈。最后将子树栈弹出，作为表达式树的根节点；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">将 # 入操作符栈;</span><br><span class="line"><span class="keyword">while</span>(!cin.<span class="built_in">get</span>(alpha))&#123;</span><br><span class="line">    <span class="keyword">if</span>(读入的字符是数字) 创建节点，将该节点压入子树栈;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(读入左括号) 压入操作符栈;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(读入右括号)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                操作符栈出栈，构造新的节点;</span><br><span class="line">                将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">                将节点压入子树栈;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(读入运算符)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">top</span>()优先级不低于运算符)&#123;</span><br><span class="line">                操作符栈出栈，构造新的节点;</span><br><span class="line">                将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">                将节点压入子树栈;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">	操作符栈出栈，构造新的节点;</span><br><span class="line">	将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">	将节点压入子树栈;</span><br><span class="line">&#125;</span><br><span class="line">返回子树栈顶，作为表达式树的根节点;</span><br></pre></td></tr></table></figure>
<h5 id="计算表达式树"><a href="#计算表达式树" class="headerlink" title="计算表达式树"></a>计算表达式树</h5><h6 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h6><p>仿后续遍历和后缀表达式计算方法，构造操作数栈</p>
<ul>
<li>按照后序遍历去访问表达式树的每个节点<ul>
<li>若节点是数字，则将其压入操作数栈</li>
<li>若节点是操作符，则对操作数栈进行两次出栈进行运算，将运算结果压栈</li>
</ul>
</li>
<li>初始操作：从根开始后序遍历；终止操作：遍历结束，弹出操作数栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(访问 == <span class="literal">NULL</span>) <span class="keyword">return</span></span><br><span class="line">访问左子树;</span><br><span class="line">访问右子树;</span><br><span class="line"><span class="keyword">if</span>(根节点是数字) 将数字压入操作数栈;</span><br><span class="line"><span class="keyword">else</span> 将操作数栈出栈两次，将运算结果压栈;</span><br></pre></td></tr></table></figure>
<h4 id="中序线索树"><a href="#中序线索树" class="headerlink" title="*中序线索树"></a>*中序线索树</h4><h5 id="建立中序线索树"><a href="#建立中序线索树" class="headerlink" title="建立中序线索树"></a>建立中序线索树</h5><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ul>
<li>从 First 节点开始，设置为 p</li>
<li>循环：访问 p 节点； 访问 p 节点的右子树：若是线索树，则p = 右子树，否则p = 右子树的 <em>左子树（\</em>左子树）</li>
<li>终止条件：右子树为 NULL</li>
</ul>
<h5 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h5><ul>
<li>从Root节点开始，设置为 p</li>
<li>循环：访问 p 节点；如果 p 节点有真左子树，设置 p 为其左子树。否则如果 p 节点有右子树，设置 p 为其真右子树。否则循环取 p 的后继线索，查看其是否存在右子树，如果有，则取p等于该右子树</li>
<li>终止条件：右子树是NULL</li>
</ul>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><ul>
<li>队列，数组，完全二叉树</li>
<li>顺序结构实现，根节点位于 1 处；k 节点的子节点为 2k，2k+1；k 节点的父节点为 k/2</li>
<li>入队，放在数组末尾；循环{与父节点比较，若父节点小，则依次向上取代}，停止条件{hole == 1；x &lt; array[hole/2]}，将 hole 处赋值新加入节点</li>
<li>出队，保存根节点值；将根节点值用数组末尾的值取代，再向下调节根节点处，保证堆的有序性</li>
</ul>
<h4 id="普通构造，析构，判空，返回首节点"><a href="#普通构造，析构，判空，返回首节点" class="headerlink" title="普通构造，析构，判空，返回首节点"></a>普通构造，析构，判空，返回首节点</h4><ul>
<li>普通构造函数申请新 array，初始化最大容量 maxSize，当前数量 currentSize</li>
<li>析构函数，析构 array 数组</li>
<li>返回 当前数量为0</li>
<li>返回 数组的第一个元素</li>
</ul>
<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ul>
<li>当堆满时（currentsize == maxSize - 1），翻倍容量</li>
<li>声明洞的位置，循环与父节点比较；停止条件{hole == 1；x &gt;= array[hole/2]}</li>
<li>将入队元素放置在洞的位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentSize == maxSize - <span class="number">1</span>) <span class="built_in">doubleSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hole = ++ currentSize;</span><br><span class="line"><span class="keyword">for</span>(;hole &gt; <span class="number">1</span>&amp;&amp; x &lt; array[hole/<span class="number">2</span>];hole/=<span class="number">2</span>)&#123;</span><br><span class="line">    array[hole] = array[hole/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = x;</span><br></pre></td></tr></table></figure>
<h4 id="出队和辅助函数-percolateDown"><a href="#出队和辅助函数-percolateDown" class="headerlink" title="出队和辅助函数 percolateDown"></a>出队和辅助函数 percolateDown</h4><h5 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h5><ul>
<li>percolate - 渗下</li>
<li>功能：当前节点的子树都保证有序性时，保证当前节点的有序性</li>
<li>取洞处的值，循环{找到最大的子树；比较洞与最大子树，若洞更大，交换子树与洞}；停止条件{没有子树；子树比洞更大}</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type tmp = array[hole];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;hole*<span class="number">2</span>&lt;= currentSize;hole = child)&#123;</span><br><span class="line">    child = hole * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(右子树比左子树更小) ++child;</span><br><span class="line">    <span class="keyword">if</span>(更小的子树 &lt; tmp) array[hole] = array[child];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = tmp;</span><br></pre></td></tr></table></figure>
<h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">保存头节点;</span><br><span class="line">头节点用数组末尾节点替代;</span><br><span class="line"><span class="built_in">percolateDown</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> 保存值;</span><br></pre></td></tr></table></figure>
<h4 id="新构造和辅助函数-buildHeap"><a href="#新构造和辅助函数-buildHeap" class="headerlink" title="新构造和辅助函数 buildHeap"></a>新构造和辅助函数 buildHeap</h4><h5 id="辅助函数-1"><a href="#辅助函数-1" class="headerlink" title="辅助函数"></a>辅助函数</h5><ul>
<li>buildHeap 构建堆</li>
<li>从下至上遍历所有有子树的节点，调用 percolateDown 函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(currentSize/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i))&#123;</span><br><span class="line">    <span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新构造"><a href="#新构造" class="headerlink" title="新构造"></a>新构造</h5><ul>
<li>初始化列表：最大容量(size + 10)，当前数量(size)</li>
<li>先构造一棵完全二叉树，再构建堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;size;++i)&#123;</span><br><span class="line">    array[i+<span class="number">1</span>] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">buildHeap</span>();</span><br></pre></td></tr></table></figure>
<h3 id="D堆"><a href="#D堆" class="headerlink" title="D堆"></a>D堆</h3><ul>
<li><p>每个节点有d个儿子，这样生成的堆比较矮</p>
</li>
<li><p>插入：O(logdN)</p>
</li>
<li><p>删除：需要在d个元素中找出最小的，时间复杂度为：O(dlogdN)</p>
</li>
<li><p>优点：插入快</p>
</li>
<li><p>缺点：删除慢</p>
</li>
<li><p>用途：</p>
<ul>
<li><p>插入比删除多的队列</p>
</li>
<li><p>队列太大，内存放不下，要放在外存的时候</p>
</li>
</ul>
</li>
</ul>
<h3 id="左堆"><a href="#左堆" class="headerlink" title="左堆"></a>左堆</h3><ul>
<li>空路径长度（NPL）<ul>
<li>Npl(x) 为 x 到不满两个子树的节点的最短路径。具有 0 个或 1 个子节点的节点的 npl 为0，npl（NULL） = -1</li>
</ul>
</li>
<li>左堆：左子树的 npl 大于等于 右子树的npl</li>
<li>特征：左堆是向左倾斜的堆</li>
</ul>
<h5 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h5><ul>
<li>将根节点值更大的堆 A 与另一个堆 B 的右子树归并，作为堆 B 的右子树</li>
<li>如果产生的新堆 右子树npl &gt; 左子树npl 则交换左右子树</li>
<li>递归终止条件：其中一个堆为空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">node * <span class="title">merge</span><span class="params">(node* root1, node* root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="keyword">if</span>(root2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    root-&gt;val &lt; root2 -&gt; val ? (l = root1, r = root2) : (l = root2, r = root1);</span><br><span class="line">    </span><br><span class="line">    l -&gt; right = <span class="built_in">merge</span>(l-&gt;right,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l -&gt; left == <span class="literal">NULL</span> || l-&gt;right -&gt; npl &gt; l-&gt;left-&gt;npl)</span><br><span class="line">        <span class="built_in">swap</span>(l-&gt;right,l-&gt;left);</span><br><span class="line">    l-&gt;npl = l-&gt;left -&gt; npl + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合与静态查找"><a href="#集合与静态查找" class="headerlink" title="集合与静态查找"></a>集合与静态查找</h2><h3 id="数据类型-set"><a href="#数据类型-set" class="headerlink" title="数据类型 - set"></a>数据类型 - set</h3><ul>
<li>每个数据元素有个区别与其他元素的唯一标识符，称为关键字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY</span>, <span class="keyword">class</span> <span class="title">OTHER</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SET</span>&#123;</span></span><br><span class="line">	KEY key;</span><br><span class="line">    OTHER other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li>允许任何容器存储集合</li>
<li>常用的比如线性表和树</li>
<li>唯一仅适用于集合的存储的数据结构为散列表</li>
</ul>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><ul>
<li>用于查找的集合为查找表</li>
<li>分类<ul>
<li>静态查找表：数据相对稳定，鲜有变化（顺序存储）</li>
<li>动态查找表：有频繁的插入、删除操作（链式存储）</li>
<li>内部查找：一次性放入内存</li>
<li>外部查找：分批</li>
</ul>
</li>
</ul>
<h3 id="无序表的查找"><a href="#无序表的查找" class="headerlink" title="无序表的查找"></a>无序表的查找</h3><ul>
<li>线性的顺序查找</li>
<li>利用哨兵来减少比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置哨兵</span></span><br><span class="line">    data[<span class="number">0</span>].key = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);x!=data[i].key;--i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><ul>
<li>与无序表的顺序查找类似</li>
<li>不需要查找到表头</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从小到大有序排列的有序表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 设置哨兵</span></span><br><span class="line">    data[<span class="number">0</span>].key = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);x&lt;data[i].key;--i);</span><br><span class="line">    <span class="keyword">if</span>(x == data[i].key) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>双 flag：low，high</li>
<li>mid 由 low , high 二分生成，比较，根据大小改变 low, high</li>
<li>终止条件：x == data[mid].key or low &gt; high</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">high</span><span class="params">(size)</span>,mid</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == data[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;data[mid].key) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul>
<li>线性插值</li>
<li>应用于分布均匀的情况</li>
</ul>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><ul>
<li>将数据集成打包成块</li>
<li>块间必须是有序的</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ul>
<li>从数组首开始，向前比较（默认向前方向已经排好序）</li>
<li>从待排元素前一个元素开始，如果该元素大于待排元素，则该元素后挪</li>
<li>赋值待排元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;size;++j)&#123;</span><br><span class="line">    tmp = array[j];</span><br><span class="line">    <span class="keyword">for</span>( k = j<span class="number">-1</span>;k&gt;=<span class="number">0</span>&amp;&amp;tmp &lt; array[k];--k)</span><br><span class="line">        array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">    array[k+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h4><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>选择增量序列（一般建议从N/2平分至1），倒序间隔直接插入排序</li>
<li>特性：h_k 有序的数组经过 h_k-1 排序后仍然是  h_k 有序的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(step = size/<span class="number">2</span>;step &gt; <span class="number">0</span>;step/=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(i = step;i&lt;size;++i)&#123;</span><br><span class="line">        tmp = a[i];</span><br><span class="line">		<span class="keyword">for</span>(j = i-step;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;tmp;j-=step)</span><br><span class="line">            a[j+step] = a[j];</span><br><span class="line">		a[j+step] = tmp;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack+</title>
    <url>/2021/04/02/Knapsack+/</url>
    <content><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><h4 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h4><h5 id="问题重述："><a href="#问题重述：" class="headerlink" title="问题重述："></a>问题重述：</h5><p>​        有N种物品和一个容量为$V$的背包。第i种物品最多有$M[i]$件可用，每件耗费的空间是$C[i]$，价值是$W[i]$。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<h5 id="问题思路："><a href="#问题思路：" class="headerlink" title="问题思路："></a>问题思路：</h5><p>解法同0-1背包问题，将$M[i]$件第$i$种物品拆开为$M[i]$件独立的一件，体积为$C[i]$，价值为$W[i]$</p>
<h5 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><script type="math/tex; mode=display">
F(N，V)= max\{ F(N-1，V)，F(N，V-C[N])+W[N] \}</script><h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>仍然考虑二进制思想，把第i种物品换成若干个物品</p>
<p>其中使每件物品相关参数前都有一个系，这些系数分别为</p>
<p>$1，2，4，8……2^k $（使得$2^{(k+1)}-1$的物品个数超过$M[I]$）</p>
<p>这样可以将$N$种情况减少到$log N$种情况</p>
<h3 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h3><h4 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h4><h5 id="问题重述：-1"><a href="#问题重述：-1" class="headerlink" title="问题重述："></a>问题重述：</h5><blockquote>
<p>如果将前面1、2、3中的三种背包问题混合起来。也就是说，有的物品只可以取一次（0-1背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p>
</blockquote>
<h5 id="问题思路：-1"><a href="#问题思路：-1" class="headerlink" title="问题思路："></a>问题思路：</h5><p>考虑到0-1背包问题相比完全背包问题的代码只有一处不同</p>
<p>同时多重背包问题又可以通过二进制思想快速简化为0-1背包问题</p>
<p>可使用伪代码表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to N</span><br><span class="line">	if 第i件物品属于01背包</span><br><span class="line">		ZeroOnePack(F,C_i,W_i)</span><br><span class="line">	else if 第i件物品属于完全背包</span><br><span class="line">		CompletePack(F,C_i,W_i)</span><br><span class="line">	else if 第i件物品属于多重背包</span><br><span class="line">		MultiplePack(F,C_i,W_i,N_i)</span><br></pre></td></tr></table></figure>
<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>面对多重大问题可以分别分拆成小问题去解决：</p>
<p>对于混合背包问题本质上是0-1，完全背包和多重背包的结合</p>
<p>因此分别调用相关的算法去解决就行</p>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>0-1问题描绘决策问题的是否</p>
<p>当出现决策问题可以取遍整数的时候，可以采用二进制思路化成0-1决策问题</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2021/12/29/HTML/</url>
    <content><![CDATA[<p>URL：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">https://developer.mozilla.org/zh-CN/docs/Web/HTML</a></p>
<p>摘要：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a> (HyperText Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的<strong>标记语言</strong>。HTML 可复杂、可简单，一切取决于开发者。它由一系列的<strong>元素（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Element">elements</a>）</strong>组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Tag">tags</a>）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 </p>
<span id="more"></span>
<hr>
<p>学习小tip：用记事本编辑 HTML 语言，用 chrome 打开，可以实时查看运行结果。</p>
<p>几种前端语言</p>
<ul>
<li>HTML 网页含义和结构</li>
<li>CSS 描述网页的表现与展示</li>
<li>JavaScript 功能和行为</li>
</ul>
<h2 id="Chapter-1-HTML-基础"><a href="#Chapter-1-HTML-基础" class="headerlink" title="Chapter 1 HTML 基础"></a>Chapter 1 HTML 基础</h2><h3 id="Section-1-HTML-介绍"><a href="#Section-1-HTML-介绍" class="headerlink" title="Section 1 HTML 介绍"></a>Section 1 HTML 介绍</h3><ol>
<li><p>标签（不区分大小写）</p>
</li>
<li><p>嵌套</p>
</li>
<li><p>块级元素和内联元素</p>
<ul>
<li>块级元素 <ul>
<li>独立成行</li>
<li>不能被嵌入内联元素</li>
</ul>
</li>
<li>内联元素<ul>
<li>不会导致文本换行</li>
</ul>
</li>
</ul>
</li>
<li><p>属性</p>
</li>
<li><p>标签 &lt; a &gt;</p>
<ul>
<li>href : 声明超链网页的网址</li>
<li>title：为超链接声明额外信息</li>
<li>target：指定链接呈现方法</li>
</ul>
</li>
<li><p>HTML 文档结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的测试站点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是我的页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是注释 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Section-2-标签-lt-head-gt"><a href="#Section-2-标签-lt-head-gt" class="headerlink" title="Section 2 标签&lt; head &gt;"></a>Section 2 标签&lt; head &gt;</h3><ol>
<li><p>&lt; head &gt; … &lt; /head &gt;</p>
</li>
<li><p>元数据：&lt; meta &gt; 元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> = <span class="string">&quot;author&quot;</span> <span class="attr">content</span> = <span class="string">&quot;QiuShi&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> = <span class="string">&quot;description&quot;</span> <span class="attr">content</span> = <span class="string">&quot;ABAB&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span> = <span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span> = <span class="string">&quot;&quot;</span> <span class="attr">type</span> = <span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用 CSS 和 JavaScript</p>
<ul>
<li>&lt; link > 元素经常位于文档的头部<ul>
<li>rel=”stylesheet”表明这是文档的样式表</li>
<li>href 包含了样式表文件的路径</li>
</ul>
</li>
<li>&lt; script &gt; 一般放在文档的尾部<ul>
<li>src 属性包含 JS 文件的路径</li>
<li>含有结束标记</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Section-3-文字处理基础"><a href="#Section-3-文字处理基础" class="headerlink" title="Section 3 文字处理基础"></a>Section 3 文字处理基础</h3><ol>
<li><p>标题和段落</p>
<ul>
<li>标题 &lt; h1 &gt;&lt; h2 &gt;&lt; h3 &gt;&lt; h4 &gt;&lt; h5 &gt;&lt; h6 &gt;</li>
<li>段落 &lt; p &gt;</li>
</ul>
</li>
<li><p>结构层次</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>第一回 宴桃园豪杰三结义 斩黄巾英雄首立功<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>第二回 张翼德怒鞭督邮 何国舅谋诛宦竖<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>且说董卓字仲颖，陇西临洮人也，官拜河东太守，自来骄傲。当日怠慢了玄德，张飞性发，便欲杀之……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>却说张飞<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>却说张飞饮了数杯闷酒，乘马从馆驿前过，见五六十个老人，皆在门前痛哭。飞问其故，众老人答曰：“督邮逼勒县吏，欲害刘公；我等皆来苦告，不得放入，反遭把门人赶打！”……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>语义</p>
<ul>
<li>&lt; h1 &gt; &lt; /h1 &gt; 类型是语义元素，含有 “一级标题” 的含义</li>
<li>&lt; span style=”font-size: 32px; margin: 21px 0;” &gt;这是顶级标题吗？&lt; /span &gt; 类型是非语义元素，虽然显示相同</li>
</ul>
</li>
<li><p>列表</p>
<ul>
<li><p>无序 (Unordered Lists)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>豆浆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>油条<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>豆汁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>焦圈<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有序 (Ordered Lists)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>沿着条路走到头<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>右转<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>直行穿过第一个十字路口<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>在第三个十字路口处左转<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>继续走 300 米，学校就在你的右手边<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套</p>
</li>
</ul>
</li>
<li><p>重点强调</p>
<ul>
<li>&lt; em &gt;&lt; /em &gt; 标记斜体</li>
<li>&lt; strong &gt; &lt; /strong> 标记粗体</li>
<li>上述均为意义明确的语义元素，&lt; b &gt;&lt; i &gt;&lt; u &gt; 为表象元素</li>
</ul>
</li>
</ol>
<h3 id="Section-4-建立超链接"><a href="#Section-4-建立超链接" class="headerlink" title="Section 4 建立超链接"></a>Section 4 建立超链接</h3><ol>
<li>链接的解析<ul>
<li>属性 href：指向希望链接的网址</li>
<li>内容 string：绑定的文本</li>
<li>当内容缺省时，不显示链接</li>
</ul>
</li>
<li>title 属性 添加支持信息<ul>
<li>效果：当鼠标悬停时，将作为提示信息出现</li>
</ul>
</li>
<li>块级链接<ul>
<li>将整块元素作为 &lt; a &gt; 的 string 属性，可将整块元素都作为标签</li>
<li>常用的比如图像</li>
</ul>
</li>
<li><p>下载链接 download 属性</p>
<ul>
<li>缺省时默认为预览状态</li>
<li>否则强制下载链接，并命名为属性的值</li>
</ul>
</li>
<li><p>电子邮件链接</p>
<ul>
<li>&lt; a &gt; 和 mailto 方案</li>
<li>使用形式为 mailto: link 格式 ， link 是缺省的</li>
</ul>
</li>
</ol>
<h3 id="Section-5-高阶文字排版"><a href="#Section-5-高阶文字排版" class="headerlink" title="Section 5 高阶文字排版"></a>Section 5 高阶文字排版</h3><ol>
<li><p>描述列表：标记一组项目及其相关描述</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>内心独白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>语言独白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>旁白<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用</p>
</li>
<li><p>缩略语</p>
<ul>
<li>&lt; abbr title = ‘ ‘ &gt;string&lt; /abbr &gt;，当鼠标放在 string 上时，会弹出 title属性值表示对其解释</li>
<li>引用词下方有虚下划线</li>
</ul>
</li>
<li><p>标记联系方式</p>
</li>
<li>上下标：&lt; sup &gt; &lt; sub &gt;</li>
<li>标记时间日期<ul>
<li>&lt; time datetime = ‘  ‘ &gt;string&lt; /time &gt;</li>
<li>datatime 表示 日期的格式化</li>
</ul>
</li>
</ol>
<h3 id="Section-6-文档与网站架构"><a href="#Section-6-文档与网站架构" class="headerlink" title="Section 6 文档与网站架构"></a>Section 6 文档与网站架构</h3><ol>
<li>文档的基本组成部分<ul>
<li>页眉 &lt; header &gt;</li>
<li>导航栏 &lt; nav &gt;</li>
<li>主内容 &lt; main &gt;</li>
<li>侧边栏 &lt; aside &gt;</li>
<li>页脚 &lt; footer &gt;</li>
</ul>
</li>
<li>HTML 布局元素细节<ul>
<li>&lt; main &gt; 只能用一次，且位于 &lt; body &gt; 中</li>
<li>&lt; article &gt; 仅包围一篇文章</li>
<li>&lt; section &gt; 组织结构使其按功能划分</li>
<li>&lt; aside &gt; 包含简介信息</li>
<li>&lt; nav &gt; 包含页面主导航，不能包含二级链接等内容</li>
</ul>
</li>
<li>无语义元素<ul>
<li>&lt; span &gt; 是内联无语义元素</li>
<li>&lt; div &gt; 是块级无语义元素</li>
</ul>
</li>
<li>换行符和水平分割线<ul>
<li>&lt; br &gt;</li>
<li>&lt; hr &gt;</li>
</ul>
</li>
</ol>
<h3 id="Section-7-HTML-调试"><a href="#Section-7-HTML-调试" class="headerlink" title="Section 7 HTML 调试"></a>Section 7 HTML 调试</h3><ol>
<li>浏览器解析 HTML 代码条件宽松，允许可控的逻辑和语法错误</li>
<li>HTML 验证 <a href="https://validator.w3.org/">Markup Validation Service</a></li>
</ol>
<hr>
<h2 id="Chapter-2-多媒体与嵌入"><a href="#Chapter-2-多媒体与嵌入" class="headerlink" title="Chapter 2 多媒体与嵌入"></a>Chapter 2 多媒体与嵌入</h2><h3 id="Section-1-HTML-中的图片"><a href="#Section-1-HTML-中的图片" class="headerlink" title="Section 1 HTML 中的图片"></a>Section 1 HTML 中的图片</h3><ol>
<li><p>&lt; img &gt; 元素（替换元素）</p>
<ul>
<li>src 属性指向引入图片的路径</li>
<li>alt 属性表示对图片的文字描述<ul>
<li>存在于图片无法显示或不能被看到的情况</li>
</ul>
</li>
<li>width 和 height 属性<ul>
<li>建议使用 CSS 改变图片的尺寸</li>
</ul>
</li>
<li>title 属性提供进一步的支持信息<ul>
<li>悬停显示</li>
</ul>
</li>
</ul>
</li>
<li><p>搭配说明文字来解说图片</p>
<ul>
<li><p>无语义类型</p>
<ul>
<li>&lt; div &gt; &lt; img &gt; &lt; p &gt; &lt; /div &gt; 类型</li>
</ul>
</li>
<li><p>语义类型</p>
<ul>
<li><p>&lt; figure &gt; 和 &lt; figcaption &gt; 元素</p>
</li>
<li><p>~~~html<br><figure><br>  &lt;img src=”<a href="https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg">https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg</a>“</p>
<pre><code> alt=&quot;一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。&quot;
 width=&quot;400&quot;
 height=&quot;341&quot;&gt;
</code></pre><p>  <figcaption>曼彻斯特大学博物馆展出的一只霸王龙的化石</figcaption><br>&lt;/figure&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. CSS 背景图片</span><br><span class="line"></span><br><span class="line">   ~~~css</span><br><span class="line">   p &#123;</span><br><span class="line">     background-image: url(&quot;images/dinosaur.jpg&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Section-2-视频和音频内容"><a href="#Section-2-视频和音频内容" class="headerlink" title="Section 2 视频和音频内容"></a>Section 2 视频和音频内容</h3><ol>
<li><p>嵌入视频 &lt; video &gt;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.webm&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>src 属性<ul>
<li>指向想要嵌入页面的视频资源</li>
</ul>
</li>
<li>controls 属性<ul>
<li>包含浏览器提供的控件功能</li>
<li>也可以自行创造页面</li>
</ul>
</li>
<li>&lt; video &gt; 标签内的内容<ul>
<li>当浏览器不支持 video 的时候，将会回退这部分内容</li>
</ul>
</li>
</ul>
</li>
<li><p>多个播放源提供兼容性</p>
<ul>
<li>容器格式</li>
</ul>
</li>
</ol>
<h3 id="Section-3-从-lt-object-gt-到-lt-iframe-gt-其他嵌入技术"><a href="#Section-3-从-lt-object-gt-到-lt-iframe-gt-其他嵌入技术" class="headerlink" title="Section 3 从 &lt; object &gt; 到 &lt; iframe &gt; - 其他嵌入技术"></a>Section 3 从 &lt; object &gt; 到 &lt; iframe &gt; - 其他嵌入技术</h3><h3 id="Section-4-页面中添加矢量图形"><a href="#Section-4-页面中添加矢量图形" class="headerlink" title="Section 4 页面中添加矢量图形"></a>Section 4 页面中添加矢量图形</h3><ol>
<li><p>图形类型</p>
<ul>
<li>位图：使用像素网格来定义，包含每个像素的位置和色彩信息<ul>
<li>bmp，png，jpg，gif</li>
</ul>
</li>
<li>矢量图：包含了图形和路径的定义，电脑根据定义在屏幕上进行渲染<ul>
<li>SVG</li>
</ul>
</li>
</ul>
</li>
<li><p>SVG 矢量图</p>
<ul>
<li>用于描述矢量图像的 XML 语言</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">baseProfile</span>=<span class="string">&quot;full&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">r</span>=<span class="string">&quot;90&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>将 SVG 嵌入页面</p>
<ul>
<li>&lt; img &gt; 在 src 属性中引用</li>
</ul>
</li>
</ol>
<h3 id="Section-5-响应式图片"><a href="#Section-5-响应式图片" class="headerlink" title="Section 5 响应式图片"></a>Section 5 响应式图片</h3><ol>
<li>自适应的图片</li>
</ol>
<hr>
<h2 id="Chapter-3-HTML-表格"><a href="#Chapter-3-HTML-表格" class="headerlink" title="Chapter 3 HTML 表格"></a>Chapter 3 HTML 表格</h2><hr>
<h2 id="Chapter-4-HTML-表单"><a href="#Chapter-4-HTML-表单" class="headerlink" title="Chapter 4 HTML 表单"></a>Chapter 4 HTML 表单</h2>]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2021/04/01/Knapsack/</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><h5 id="问题重述："><a href="#问题重述：" class="headerlink" title="问题重述："></a>问题重述：</h5><blockquote>
<p>有N件物品和一个容量为$V$的背包。放入第i件物品耗费的空间是$C[i]$，得到的价值是$W[i]$。求解将哪些物品装入背包可使价值总和最大。</p>
</blockquote>
<h5 id="问题思路："><a href="#问题思路：" class="headerlink" title="问题思路："></a>问题思路：</h5><p>任何一件物品可以选择放入或者不放入,考虑第$N$件物品：</p>
<ul>
<li>放入：问题简化为 $N-1$ 件物品，容量为$V-C[N]$， 得到的价值为$F(N-1，V-C[N])+W[N]$</li>
<li>不放入：问题简化为$N-1$件物品，容量为$V$，得到的价值为$F(N-1，V)$</li>
</ul>
<h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><script type="math/tex; mode=display">
F(N，V)= max\{F(N-1，V)，F(N-1，V-C[N])+W[N]\}</script><h5 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(x,y)</span> </span>&#123;<span class="keyword">return</span> (x&gt;y)? x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s[],<span class="keyword">int</span> v[],<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当没有物品可选或者可以存储的质量小于等于0时，显然能存储的物品价值为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[n]&gt;C) <span class="keyword">return</span> <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">// 当第N件物品质量超过所能容纳质量时，可以默认不选</span></span><br><span class="line">    <span class="comment">// 事实上这一步也可以忽略，可以包含在第三种情况中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C),<span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C-s[n])+v[n]);</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>倘若直接调用递归函数，会出现重复计算的问题</p>
<p>如果能出现一个数组来存储每次计算的结果时，可以减少重复计算的机会</p>
<p><strong>动态规划：</strong></p>
<h5 id="C-代码实现-1"><a href="#C-代码实现-1" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划解决0-1背包问题</span></span><br><span class="line"><span class="keyword">int</span> packarray[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// packarray[n][C] 用于储存前n件物品，容量为C的背包最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s[], <span class="keyword">int</span> v[], <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packarray[n][C]) <span class="keyword">return</span> packarray[n][C]; <span class="comment">//若已经计算过，则直接引用，避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[n]&gt;C) &#123;packarray[n][C] = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="keyword">return</span> packarray[n][C];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tem1 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">//不取第n件的情况</span></span><br><span class="line">        <span class="keyword">int</span> tem2 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C-s[n])+v[n]; <span class="comment">//取第n件的情况</span></span><br><span class="line">        <span class="keyword">if</span> (tem1&gt;tem2) packarray[n][C] = tem1;</span><br><span class="line">        <span class="keyword">else</span> packarray[n][C] = tem2;</span><br><span class="line">        <span class="keyword">return</span> packarray[n][C];  <span class="comment">//比较并赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化细节"><a href="#初始化细节" class="headerlink" title="初始化细节"></a>初始化细节</h3><p>如果要求背包刚好装满，则可以设$knapsack(0，a)(a != 0)$时取值无穷小，此时无法取到背包未满的解。</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h3><h5 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述:"></a>问题重述:</h5><blockquote>
<p>有N种物品和一个容量为V 的背包，每种物品都有<strong>无限件可用</strong>。放入第i种 物品的耗费的空间是C[i]，得到的价值是W[i]。求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
</blockquote>
<h5 id="问题思路：-1"><a href="#问题思路：-1" class="headerlink" title="问题思路："></a>问题思路：</h5><h6 id="思路1-1："><a href="#思路1-1：" class="headerlink" title="思路1-1："></a>思路1-1：</h6><p>（转换为0-1背包问题）</p>
<p>仍然以0-1背包问题进行理解，虽然每件物品有无限件可用，但是为保证物品数量不超过空间限制，至多可选第i件物品的个数为$[ C/C[i] ]$,因此问题变为了$[C/C[i]]$个i件物品的综合。</p>
<p>但可见当物品数目增多，容量增大时，该算法的复杂度会迅速<strong>膨胀</strong>。</p>
<h6 id="思路1-2："><a href="#思路1-2：" class="headerlink" title="思路1-2："></a>思路1-2：</h6><p>（更有效的转换为0-1背包问题）</p>
<p>把第i种物品拆成体积为$C[i]<em>2^k$、价值为$W[i]</em> 2^k$的若干件物品，其中k取遍满足$C[i]* 2^k ≤ V$ 的非负整数。</p>
<p><u>即采用二进制的思想，当选取两件相同物品时，等价于选取质量和价值均为原来两倍的物品</u>。</p>
<h6 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h6><p>一个简单的优化：若两件物品比较，其中一件物品价值更低，同时体积更大，那么可以将这一件物品舍去。</p>
<h6 id="思路3："><a href="#思路3：" class="headerlink" title="思路3："></a>思路3：</h6><p>当且仅当决定不继续选择这件物品时进行状态转移，否则持续当前状态</p>
<h5 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul>
<li><script type="math/tex; mode=display">F(N，V)= max\{ F(N-1，V - k * C[N]) + k * W[N] |0<=k * C[N]<=V \}</script></li>
<li><script type="math/tex; mode=display">F(N，V)= max\{ F(N-1，V)，F(N，V-C[N])+W[N] \}</script></li>
</ul>
<h5 id="C-代码实现-2"><a href="#C-代码实现-2" class="headerlink" title="C++代码实现"></a>C++代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划解决完全背包问题</span></span><br><span class="line"><span class="keyword">int</span> packarray[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// packarray[n][C] 用于储存前n件物品，容量为C的背包最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s[], <span class="keyword">int</span> v[], <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packarray[n][C]) <span class="keyword">return</span> packarray[n][C]; <span class="comment">//若已经计算过，则直接引用，避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">0</span>||C&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[n]&gt;C) &#123;packarray[n][C] = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="keyword">return</span> packarray[n][C];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tem1 = <span class="built_in">knapsack</span>(n<span class="number">-1</span>,s,v,C); <span class="comment">//不取第n件的情况</span></span><br><span class="line">        <span class="keyword">int</span> tem2 = <span class="built_in">knapsack</span>(n,s,v,C-s[n])+v[n]; <span class="comment">//取第n件的情况</span></span><br><span class="line">        <span class="keyword">if</span> (tem1&gt;tem2) packarray[n][C] = tem1;</span><br><span class="line">        <span class="keyword">else</span> packarray[n][C] = tem2;</span><br><span class="line">        <span class="keyword">return</span> packarray[n][C];  <span class="comment">//比较并赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h2><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>​         在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。</p>
<p>​        各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。</p>
<p>​         在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法</p>
</blockquote>
<h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><blockquote>
<p>​        动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>​         动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</p>
<p>​         若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy_base</title>
    <url>/2021/08/01/Numpy_base/</url>
    <content><![CDATA[<h2 id="理解Numpy"><a href="#理解Numpy" class="headerlink" title="理解Numpy"></a>理解Numpy</h2><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/numpy-logo-300.png" alt="img"></p>
<p>围绕数据类型ndarray 建立起的高级数据操作和数值计算的python库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li>类似matlab，数组的计算采用逐元素计算</li>
<li>底层实现基于C，因此计算速度远快于python本体</li>
</ul>
<h3 id="Ndarray"><a href="#Ndarray" class="headerlink" title="Ndarray"></a>Ndarray</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/ndarray.png" alt="img"></p>
<ul>
<li><p>存放同类型数据的多维数组</p>
</li>
<li><p>高级数组，比起数据集合（例如List）更像多维矩阵的结构</p>
</li>
<li>相对于python本体的动态储存结构，ndarrays一旦生成了，规模就不可改变</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">object</td>
<td style="text-align:left">数组或嵌套的数列</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">数组元素的数据类型，可选</td>
</tr>
<tr>
<td style="text-align:left">copy</td>
<td style="text-align:left">对象是否需要复制，可选</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td style="text-align:left">subok</td>
<td style="text-align:left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td style="text-align:left">ndmin</td>
<td style="text-align:left">指定生成数组的最小维度</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Ndarray生成函数"><a href="#Ndarray生成函数" class="headerlink" title="Ndarray生成函数"></a>Ndarray生成函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(x,dtype=<span class="built_in">float</span>)  <span class="comment">#将输入数据x转换为指定类型dtype的ndarray</span></span><br><span class="line">np.asarray(array)  <span class="comment">#将输入数据转换为一个新的（copy）的ndarray</span></span><br><span class="line">np.ones(N,dtype) </span><br><span class="line">np.ones_like(ndarray)  <span class="comment">#生成一个形状与参数数组完全相同的全1的ndarray</span></span><br><span class="line">np.zeros(N,dtype)</span><br><span class="line">np.zeros_like(ndarray)</span><br><span class="line">np.empty(N,dtype)  <span class="comment">#生成一个数据为初始化的指定类型为dtype的ndarray</span></span><br><span class="line">np.empty_like(ndarray)</span><br><span class="line">np.eye(N)</span><br><span class="line">np.identity(N)</span><br><span class="line">np.arange(begin,end,step)</span><br><span class="line">np.linspace(start,stop,num)</span><br><span class="line">np.logspace(start,stop,num)</span><br></pre></td></tr></table></figure>
<h2 id="Numpy-数据类型"><a href="#Numpy-数据类型" class="headerlink" title="Numpy 数据类型"></a>Numpy 数据类型</h2><h3 id="常用Numpy基本类型"><a href="#常用Numpy基本类型" class="headerlink" title="常用Numpy基本类型"></a>常用Numpy基本类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bool_</td>
<td style="text-align:left">布尔型数据类型（True 或者 False）</td>
</tr>
<tr>
<td style="text-align:left">int_</td>
<td style="text-align:left">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr>
<td style="text-align:left">intc</td>
<td style="text-align:left">与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr>
<td style="text-align:left">intp</td>
<td style="text-align:left">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr>
<td style="text-align:left">int8</td>
<td style="text-align:left">字节（-128 to 127）</td>
</tr>
<tr>
<td style="text-align:left">int16</td>
<td style="text-align:left">整数（-32768 to 32767）</td>
</tr>
<tr>
<td style="text-align:left">int32</td>
<td style="text-align:left">整数（-2147483648 to 2147483647）</td>
</tr>
<tr>
<td style="text-align:left">int64</td>
<td style="text-align:left">整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr>
<td style="text-align:left">uint8</td>
<td style="text-align:left">无符号整数（0 to 255）</td>
</tr>
<tr>
<td style="text-align:left">uint16</td>
<td style="text-align:left">无符号整数（0 to 65535）</td>
</tr>
<tr>
<td style="text-align:left">uint32</td>
<td style="text-align:left">无符号整数（0 to 4294967295）</td>
</tr>
<tr>
<td style="text-align:left">uint64</td>
<td style="text-align:left">无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr>
<td style="text-align:left">float_</td>
<td style="text-align:left">float64 类型的简写</td>
</tr>
<tr>
<td style="text-align:left">float16</td>
<td style="text-align:left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">float32</td>
<td style="text-align:left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">float64</td>
<td style="text-align:left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td style="text-align:left">complex_</td>
<td style="text-align:left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td style="text-align:left">complex64</td>
<td style="text-align:left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td style="text-align:left">complex128</td>
<td style="text-align:left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p>
</blockquote>
<h3 id="数据类型对象（dtype）"><a href="#数据类型对象（dtype）" class="headerlink" title="数据类型对象（dtype）"></a>数据类型对象（dtype）</h3><h4 id="构造dtype对象"><a href="#构造dtype对象" class="headerlink" title="构造dtype对象"></a>构造dtype对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure>
<ul>
<li>object - 要转换为的数据类型对象</li>
<li>align - 如果为 true，填充字段使其类似 C 的结构体。</li>
<li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li>
</ul>
<h4 id="结构化数据类型"><a href="#结构化数据类型" class="headerlink" title="结构化数据类型"></a>结构化数据类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 首先创建结构化数据类型</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line"><span class="comment"># 将数据类型应用于 ndarray 对象</span></span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="comment"># 类型字段名可以用于存取实际的 age 列</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">&gt;&gt; [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; [(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.0</span>), (<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.0</span>)]</span><br></pre></td></tr></table></figure>
<p>每个内建类型都有一个唯一定义它的字符代码，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">对应类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">布尔型</td>
</tr>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">(有符号) 整型</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">无符号整型 integer</td>
</tr>
<tr>
<td style="text-align:left">f</td>
<td style="text-align:left">浮点型</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">复数浮点型</td>
</tr>
<tr>
<td style="text-align:left">m</td>
<td style="text-align:left">timedelta（时间间隔）</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">datetime（日期时间）</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">(Python) 对象</td>
</tr>
<tr>
<td style="text-align:left">S, a</td>
<td style="text-align:left">(byte-)字符串</td>
</tr>
<tr>
<td style="text-align:left">U</td>
<td style="text-align:left">Unicode</td>
</tr>
<tr>
<td style="text-align:left">V</td>
<td style="text-align:left">原始数据 (void)</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>ndarray.reshape 通常返回的是非拷贝副本，即改变返回后数组的元素，原数组对应元素的值也会改变。</p>
</blockquote>
<h2 id="Numpy-切片和索引"><a href="#Numpy-切片和索引" class="headerlink" title="Numpy 切片和索引"></a>Numpy 切片和索引</h2><p>与python中list的切片和索引操作相似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line"><span class="built_in">print</span> (a[s])</span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line">&gt;&gt; [[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切片还可以包括省略号 <strong>…</strong>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line">&gt;&gt; [<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line">&gt;&gt; [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br><span class="line">&gt;&gt; [[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">    [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><h4 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h4><p>以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line">&gt;&gt; [<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>整体先用 [ ] 括起来表示索引</li>
<li>内部依次有ndim个序列，分别表示第i个axis</li>
<li>内部的每个序列的shape保持一致，最终索引的结果位于对应的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line">&gt;&gt; [[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">    [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line">    [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line">    [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]]) </span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]) </span><br><span class="line">y = x[rows,cols]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line">&gt;&gt; [[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line">    [ <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure>
<p>返回的结果是包含每个角元素的 ndarray 对象。</p>
<p>可以借助切片 <strong>:</strong> 或 <strong>…</strong> 与索引数组组合。如下面例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">c = a[<span class="number">1</span>:<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">d = a[...,<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">&gt;&gt; [[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">&gt;&gt; [[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">&gt;&gt; [[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">    [<span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>我们可以通过一个布尔数组来索引目标数组。</p>
<p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在我们会打印出大于 5 的元素  </span></span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x[x &gt;  <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果为</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大于 <span class="number">5</span> 的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>以下实例使用了 <strong>~</strong>（取补运算符）来过滤 NaN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([np.nan,  <span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span> (a[~np.isnan(a)])</span><br><span class="line">&gt;&gt; [ <span class="number">1.</span>   <span class="number">2.</span>   <span class="number">3.</span>   <span class="number">4.</span>   <span class="number">5.</span>]</span><br></pre></td></tr></table></figure>
<p>以下实例演示如何从数组中过滤掉非复数元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,  <span class="number">2</span>+<span class="number">6j</span>,  <span class="number">5</span>,  <span class="number">3.5</span>+<span class="number">5j</span>])  </span><br><span class="line"><span class="built_in">print</span> (a[np.iscomplex(a)])</span><br><span class="line">&gt;&gt; [<span class="number">2.0</span>+<span class="number">6.j</span>  <span class="number">3.5</span>+<span class="number">5.j</span>]</span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<p>关于 np.ix_ 的具体使用：</p>
<p>如果 np.xi_ 中输入两个列表，则第一个列表存的是待提取元素的行标，第二个列表存的是待提取元素的列标，第一个列表中的每个元素都会遍历第二个列表中的每个值，构成新矩阵的一行元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])]</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line">[[x[<span class="number">1</span>,<span class="number">0</span>] x[<span class="number">1</span>,<span class="number">3</span>] x[<span class="number">1</span>,<span class="number">1</span>] x[<span class="number">1</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">5</span>,<span class="number">0</span>] x[<span class="number">5</span>,<span class="number">3</span>] x[<span class="number">5</span>,<span class="number">1</span>] x[<span class="number">5</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">7</span>,<span class="number">0</span>] x[<span class="number">7</span>,<span class="number">3</span>] x[<span class="number">7</span>,<span class="number">1</span>] x[<span class="number">7</span>,<span class="number">2</span>]],</span><br><span class="line"> [x[<span class="number">2</span>,<span class="number">0</span>] x[<span class="number">2</span>,<span class="number">3</span>] x[<span class="number">2</span>,<span class="number">1</span>] x[<span class="number">2</span>,<span class="number">2</span>]]]</span><br></pre></td></tr></table></figure>
<p>关于普通索引和花式索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype = <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">0</span>)])</span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">#上述两种等价，本质上来说上面是下面的一种语法糖</span></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">0</span>),])</span><br><span class="line">&gt;&gt;[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">   [<span class="number">1</span> <span class="number">2</span>]]</span><br><span class="line"><span class="comment">#触发了花式缩影，默认为x[(0,0),:]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)])</span><br><span class="line">&gt;&gt;[<span class="number">1</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">&gt;&gt;[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">   [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"><span class="comment"># “:”不代表当前序列，而是对任意一种情况遍历所有序列，类似np.ix</span></span><br></pre></td></tr></table></figure>
<h2 id="Numpy广播（broadcast）"><a href="#Numpy广播（broadcast）" class="headerlink" title="Numpy广播（broadcast）"></a>Numpy广播（broadcast）</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) </span><br><span class="line">c = a * b </span><br><span class="line"><span class="built_in">print</span> (c)</span><br><span class="line">&gt;&gt; [ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure>
<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line">&gt;&gt;[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">   [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line">   [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">   [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p>
<p>可以广播的几种情况：</p>
<ol>
<li>两个数组各维度大小从后往前比对均一致</li>
<li>两个数组存在一些维度大小不相等时，有一个数组的该不相等维度大小为1</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas</title>
    <url>/2021/08/02/Pandas/</url>
    <content><![CDATA[<h1 id="理解Pandas"><a href="#理解Pandas" class="headerlink" title="理解Pandas"></a>理解Pandas</h1><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas.png" alt="img"></p>
<p><strong>Pandas 是 Python 语言的一个扩展程序库，用于数据分析。</strong></p>
<p>Pandas 是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具。</p>
<p>Pandas 名字衍生自术语 “panel data”（面板数据）和 “Python data analysis”（Python 数据分析）。</p>
<p>Pandas 一个强大的分析结构化数据的工具集，基础是 Numpy（提供高性能的矩阵运算）。</p>
<p>Pandas 可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据。</p>
<p>Pandas 可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。</p>
<p>Pandas 广泛应用在学术、金融、统计学等各个数据分析领域。</p>
<h1 id="Pandas-数据结构"><a href="#Pandas-数据结构" class="headerlink" title="Pandas 数据结构"></a>Pandas 数据结构</h1><h2 id="Series"><a href="#Series" class="headerlink" title="$Series$"></a>$Series$</h2><p>$Series$ 构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, name, copy)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>data</strong>：一组数据(ndarray 类型)。</li>
<li><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</li>
<li><strong>dtype</strong>：数据类型，默认会自己判断。</li>
<li><strong>name</strong>：设置名称。</li>
<li><strong>copy</strong>：拷贝数据，默认为 False。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">myvar = pd.Series(a)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在不指定索引值的时候默认为$0、1、2\cdots$​​序列，可以替换索引值</p>
<p>替换索引值后仍可以按照$0、1、2\cdots$序列来索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line">myvar = pd.Series(a, index = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="string">&quot;y&quot;</span>])</span><br><span class="line">&gt;&gt; Runoob</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="number">0</span>])</span><br><span class="line">&gt;&gt; Google</span><br></pre></td></tr></table></figure>
<p>我们也可以使用$ key/value $对象，类似字典来创建 $Series$：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="comment">#局部创建</span></span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>设置$Series$名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;RUNOOB-Series-TEST&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line">&gt;&gt; <span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">Name: RUNOOB-Series-TEST, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="$DataFrame$"></a>$DataFrame$</h2><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas-DataStructure.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2021/04/df-dp.png" alt="img"></p>
<p>$DataFrame$构造方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure>
<p>Pandas DataFrame 是一个二维的数组结构，类似二维数组。</p>
<p>利用二维数组构造$DataFrame$​：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [[<span class="string">&#x27;Google&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Wiki&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Site&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">&gt;&gt;      Site   Age</span><br><span class="line"><span class="number">0</span>  Google  <span class="number">10.0</span></span><br><span class="line"><span class="number">1</span>  Runoob  <span class="number">12.0</span></span><br><span class="line"><span class="number">2</span>    Wiki  <span class="number">13.0</span></span><br></pre></td></tr></table></figure>
<p>利用字典构造$DataFrame$：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span> (df)</span><br><span class="line">&gt;&gt;   a   b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br></pre></td></tr></table></figure>
<p>没有对应的部分数据为 <strong>NaN</strong>。</p>
<p>Pandas 可以使用 <strong>loc</strong> 属性返回指定行的数据，如果没有设置索引，第一行索引为 <strong>0</strong>，第二行索引为 <strong>1</strong>，以此类推：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 返回第一行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">0</span>])</span><br><span class="line">&gt;&gt; calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: <span class="number">0</span>, dtype: int64</span><br><span class="line"><span class="comment"># 返回第二行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">1</span>])</span><br><span class="line">&gt;&gt; calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: int64</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>返回结果其实就是一个 Pandas Series 数据。</p>
</blockquote>
<p>也可以返回多行数据，使用 <strong>[[ … ]]</strong> 格式，<strong>…</strong> 为各行的索引，以逗号隔开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 返回第一行和第二行</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">&gt;&gt;    calories  duration</span><br><span class="line"><span class="number">0</span>       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line"><span class="number">1</span>       <span class="number">380</span>        <span class="number">40</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>返回结果其实就是一个 Pandas DataFrame 数据</p>
</blockquote>
<p>我们可以指定索引值，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">&gt;&gt;       calories  duration</span><br><span class="line">day1       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">day2       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">day3       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&quot;day2&quot;</span>])</span><br><span class="line">calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: day2, dtype: int64</span><br></pre></td></tr></table></figure>
<h1 id="Pandas-CSV"><a href="#Pandas-CSV" class="headerlink" title="Pandas CSV"></a>Pandas CSV</h1><blockquote>
<p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p>
<p>CSV 是一种通用的、相对简单的文件格式，被用户、商业和科学广泛应用。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure>
<p><strong>to_string()</strong> 用于返回 DataFrame 类型的数据，如果不使用该函数，则输出结果为数据的前面 5 行和末尾 5 行，中间部分以 <strong>…</strong> 代替。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="head"><a href="#head" class="headerlink" title="- head()"></a>- head()</h4><blockquote>
<p>用于读取前面的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 <strong>NaN</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure>
<h4 id="tail"><a href="#tail" class="headerlink" title="- tail()"></a>- tail()</h4><blockquote>
<p>用于读取尾部的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 <strong>NaN</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h4 id="info"><a href="#info" class="headerlink" title="- info()"></a>- info()</h4><blockquote>
<p>info() 方法返回表格的一些基本信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.info())</span><br><span class="line">&gt;&gt;&lt; <span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">458</span> entries, <span class="number">0</span> to <span class="number">457</span>       </span><br><span class="line">Data columns (total <span class="number">9</span> columns): </span><br></pre></td></tr></table></figure>
<h3 id="Pandas-JSON"><a href="#Pandas-JSON" class="headerlink" title="Pandas JSON"></a>Pandas JSON</h3><h1 id="Pandas-数据清洗"><a href="#Pandas-数据清洗" class="headerlink" title="Pandas 数据清洗"></a>Pandas 数据清洗</h1><h3 id="dropna"><a href="#dropna" class="headerlink" title="- dropna()"></a>- dropna()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;any&#x27;</span>, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>axis：默认为 <strong>0</strong>，表示逢空值剔除整行，如果设置参数 <strong>axis＝1</strong> 表示逢空值去掉整列。</li>
<li>how：默认为 <strong>‘any’</strong> 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 <strong>how=’all’</strong> 一行（或列）都是 NA 才去掉这整行。</li>
<li>thresh：设置需要多少非空值的数据才可以保留下来的。</li>
<li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li>
<li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li>
</ul>
<h3 id="isnull"><a href="#isnull" class="headerlink" title="- isnull()"></a>- isnull()</h3><h3 id="fillna"><a href="#fillna" class="headerlink" title="- fillna()"></a>- fillna()</h3>]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rank_Queue</title>
    <url>/2021/11/17/Rank-Queue/</url>
    <content><![CDATA[<h1 id="排队系统模拟"><a href="#排队系统模拟" class="headerlink" title="排队系统模拟"></a>排队系统模拟</h1><p>排队系统主要有两类事件：顾客到达和服务完毕后顾客离开</p>
<p>因此这种系统又被称作<strong>离散事件模拟系统</strong></p>
<h2 id="驱动模式"><a href="#驱动模式" class="headerlink" title="驱动模式"></a>驱动模式</h2><p>离散的时间驱动模拟：沿时间轴，模拟每一个单位时间内发生了什么事件并进行处理</p>
<p>*事件驱动模拟：按照事件发生的事件排队，当一个事件处理结束后，直接跳跃到下一事件的发生事件，处理该事件</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="单服务台的排队系统"><a href="#单服务台的排队系统" class="headerlink" title="单服务台的排队系统"></a>单服务台的排队系统</h3><ul>
<li>由单个队列完成</li>
<li>模拟规则：<ul>
<li>生成所有顾客的到达时间，按照到达时间排成队列</li>
<li>当服务员处于空闲状态时，队头顾客出队；统计该顾客等待时间；</li>
<li>所有顾客都服务完毕后，求和总等待时间，除以人数得到平均等待时间</li>
</ul>
</li>
</ul>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只需要采用普通队列</span></span><br><span class="line">totalWaitTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">设置顾客开始到达的时间 currentTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;customNum;++i)&#123;</span><br><span class="line">    生成下一顾客到达的间隔时间;</span><br><span class="line">    下一顾客的到达时间 currentTime += 下一顾客到达的间隔时间;</span><br><span class="line">    将下一顾客的到达时间入队;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从时刻 <span class="number">0</span> 开始模拟;</span><br><span class="line"><span class="keyword">while</span>(顾客队列非空)&#123;</span><br><span class="line">    取队头顾客;</span><br><span class="line">    <span class="keyword">if</span>(到达时间 &gt; 当前时间) 直接将时钟拨到事件发生的时间;</span><br><span class="line">    <span class="keyword">else</span> 收集该顾客的等待时间;</span><br><span class="line">    生成服务时间;</span><br><span class="line">    将时钟拨到服务完成的时刻;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回等待时间 / 顾客数;</span><br></pre></td></tr></table></figure>
<h3 id="多服务台的排队系统"><a href="#多服务台的排队系统" class="headerlink" title="多服务台的排队系统"></a>多服务台的排队系统</h3><ul>
<li>相对于单服务台的排队系统，多服务台具有如下特点：<ul>
<li>先到达的顾客先接受服务，和单服务台相同；</li>
<li>而不一定先离开，后到达的若服务时间短，可以先离开;</li>
<li>顾客接受服务的任务不一定紧跟在前一个顾客离开</li>
</ul>
</li>
<li>事件分为到达事件和离开事件：<ul>
<li>到达事件：<ul>
<li>若有剩余服务台，顾客接受服务，剩余服务台 -1；生成服务时间，当前时间加上服务时间为离开时间，将离开事件加入任务队列；</li>
<li>若无剩余服务台，将该到达事件加入等待队列；</li>
</ul>
</li>
<li>离开事件：<ul>
<li>若等待队列非空，则将等待队列队头事件出队（统计等待时间 currentTime - currentEvent.time）；生成服务事件，当前时间加上服务事件为离开时间，将离开事件加入任务队列；</li>
<li>若等待队列为空，则剩余服务台 +1；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件队列为优先级队列</span></span><br><span class="line"><span class="comment">// 等待队列为普通队列</span></span><br><span class="line">产生 customNum 个顾客的到达事件，依次存入事件队列;</span><br><span class="line">初始化;</span><br><span class="line"><span class="keyword">while</span>(事件队列非空)&#123;</span><br><span class="line">    队头元素出队;</span><br><span class="line">    设置当前时间为事件发生的事件;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(事件类型)&#123;</span><br><span class="line">        <span class="keyword">case</span> 到达:<span class="keyword">if</span>(柜台有空)&#123;</span><br><span class="line">            柜台数--;</span><br><span class="line">            生成所需的服务时间;</span><br><span class="line">            生成新的离开事件加入事件队列;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                将该事件存入等待队列;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 离开:<span class="keyword">if</span>(等待队列非空)&#123;</span><br><span class="line">            队头元素出队;</span><br><span class="line">            统计该顾客的等待时间;<span class="comment">// currentTime - currentEvent.time</span></span><br><span class="line">            生成所需的服务时间;</span><br><span class="line">            生成新的离开事件加入事件队列;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                空闲柜台数 ++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">计算平均等待时间;</span><br><span class="line">返回;</span><br></pre></td></tr></table></figure>
<h3 id="其他排队系统"><a href="#其他排队系统" class="headerlink" title="其他排队系统"></a>其他排队系统</h3><h4 id="考虑离开队伍的情况"><a href="#考虑离开队伍的情况" class="headerlink" title="考虑离开队伍的情况"></a>考虑离开队伍的情况</h4><ul>
<li>假设存在一种情况，若顾客发现等待人数过多，则有一定可能性离开</li>
<li>步骤与上述多服务台相同，但是 到达事件，需要讨论 length(waitQueue) &gt; num 的情况，此时该顾客有一定可能性离开</li>
</ul>
<h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><p>为什么这种情况采用的是多服务台模型，即便使用的是单服务台？</p>
<p>但服务台不需要考虑离开事件，因为下一顾客接受服务事件一定在离开事件之后；而多服务台模型由于需要错开到达和离开事件，使用了等待队列：对于无法立即处理的到达事件 加入等待队列（作为缓冲区），这样就可以做到即使还在服务饱和阶段，还能处理新到达的顾客。因此考虑离开队伍的情况，使用多服务台模型更好.</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>信息检索导论</title>
    <url>/2021/10/28/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p>摘要：本书是一本讲授信息检索的经典教材。全书共 21 章，前八章详述了信息检索的基础知识，包括倒排索引、布尔检索及词项权重计算和评分算法等，后十三章介绍了一些高级话题，如基于语言建模的信息检索模型、基于机器学习的排序方法和 Web 搜索技术等。另外，本书还着重讨论了文本聚类技术这一信息检索中不可或缺的组成部分。全书语言流畅，由浅入深，一气呵成。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Chapter 1-8 核心理论</li>
<li>Chapter 9-21 高级话题</li>
</ul>
<h2 id="Chapter-1-布尔检索"><a href="#Chapter-1-布尔检索" class="headerlink" title="Chapter 1 布尔检索"></a>Chapter 1 布尔检索</h2><ol>
<li><p>信息检索（IR）：</p>
<ul>
<li>大规模非结构化数据    </li>
<li>满足用户需求    </li>
<li>特定资料</li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>结构化 - 关系数据库</li>
<li>非结构化</li>
<li>半结构化 - 网页界面</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>给定类别体系（标注） </li>
<li>扩展 （类似于 ML 领域的分类概念）</li>
</ul>
</li>
<li><p>线性扫描（×）</p>
<ul>
<li>数据量</li>
<li>匹配方式灵活</li>
<li>打分排序</li>
</ul>
</li>
<li><p>词项-文档关联矩阵：布尔值</p>
</li>
<li><p>布尔值查询    逻辑连接词 </p>
</li>
<li><p>统计信息</p>
<ul>
<li><p><strong>正确率</strong>：返回的结果中真正和信息需求相关的文档所占的百分比</p>
</li>
<li><p><strong>召回率</strong>：所有和信息需求真正相关的文档中被检索系统返回的百分比</p>
</li>
</ul>
</li>
<li><p><strong>倒排索引</strong></p>
<ul>
<li><p>关联矩阵的稀疏性 -&gt; 倒排表</p>
</li>
<li><p>倒排记录：词项 -&gt; 文档编号<img src=".\信息检索导论\image1.png" alt="image1"></p>
</li>
<li><p>构建倒排索引：收集文档 -&gt; 词条化 -&gt; 语言学处理 -&gt; 倒排索引</p>
</li>
<li>索引 —- 倒排记录表 &amp;&amp; 词项词典</li>
</ul>
</li>
<li><p>布尔查询：对倒排记录表进行合并，例如：AND -&gt; 取交</p>
</li>
<li><p>倒排记录表</p>
<ul>
<li>单链表 -&gt; 文档的插入和更新</li>
<li>变长数组 -&gt; 节省指针内存消耗，访问速度快</li>
<li>-&gt; 定长数组的链表 </li>
</ul>
</li>
<li><p>合并 -&gt; 基于文档频率的启发式算法</p>
</li>
<li><p>基于基本布尔操作的扩展</p>
<ul>
<li><strong>排序检索模型</strong> </li>
</ul>
</li>
<li><p><strong>Future Key_Points</strong></p>
<ol>
<li>容忍错误 模糊查询</li>
<li>改善结构 支持复合查询</li>
<li>非二值 引入词项频率</li>
<li>评分</li>
</ol>
</li>
</ol>
<h2 id="Chapter-2-词项词典及倒排记录表"><a href="#Chapter-2-词项词典及倒排记录表" class="headerlink" title="Chapter 2 词项词典及倒排记录表"></a>Chapter 2 词项词典及倒排记录表</h2><ol>
<li>字符序列生成<ul>
<li>字节序列<ul>
<li>文档元信息</li>
<li>手动选择</li>
<li>基于机器学习分类</li>
</ul>
</li>
<li>文字系统 - 阿拉伯语（二维和混序）<ul>
<li>发音 -&gt; 线性化</li>
</ul>
</li>
</ul>
</li>
<li>文档单位选择：<ul>
<li>索引粒度 <ul>
<li>微型文档 —- mini-document</li>
<li>权衡正确率和召回率</li>
</ul>
</li>
</ul>
</li>
<li>词条化<ul>
<li>字符序列 -&gt; 子序列</li>
<li>去掉特殊字符 -&gt; 拆分策略</li>
</ul>
</li>
<li>分词：最大匹配法和基于机器学习序列模型</li>
<li>停用词：常见词 | 与用户需求匹配的价值小</li>
<li>词项归一化<ul>
<li>将不完全一致的多个词条归纳成一个等价类 </li>
<li>词干还原<ul>
<li>去除单词两端词缀的启发式过程</li>
<li>包括去除派生词缀</li>
<li>Porter 算法</li>
</ul>
</li>
<li>词形归并<ul>
<li>利用词汇表和词形分析来去除屈折词缀</li>
<li>返回词的原形或词典中的词的过程</li>
</ul>
</li>
</ul>
</li>
<li>跳表（倒排记录表快速合并算法）<ul>
<li>启发式：在 $\sqrt{p}$ 处均匀设置跳表指针，$p$ 是倒排记录表长度</li>
</ul>
</li>
<li>含位置信息 &amp;&amp; 短语查询<ul>
<li>二元词索引 -&gt; </li>
<li>位置信息索引 -&gt;</li>
<li>后续词索引</li>
</ul>
</li>
</ol>
<h2 id="Chapter-3-词典及容错式检索"><a href="#Chapter-3-词典及容错式检索" class="headerlink" title="Chapter 3 词典及容错式检索"></a>Chapter 3 词典及容错式检索</h2><ol>
<li><p>词典搜索：哈希表、搜索树</p>
<ul>
<li>关键字的数目 Num</li>
<li>关键字数目 动态 or 静态</li>
<li>访问</li>
</ul>
</li>
<li><p>哈希表 -&gt; 哈希函数映射 —- 词汇表增长 （失效）</p>
</li>
<li><p>搜索树 -&gt; 预定义的排序方式 -&gt; 平衡化处理</p>
<p><img src=".\信息检索导论\image4.png" alt="image-20211031222110118"></p>
</li>
<li><p>通配符 -&gt; 模糊查询 、 词干还原、  -&gt; B 树、反向 B 树</p>
<ol>
<li><p>轮排索引：支持词项旋转</p>
<p><img src=".\信息检索导论\image2.png" alt="image2"></p>
</li>
<li><p>K-gram 索引</p>
</li>
</ol>
</li>
<li><p>拼写校正</p>
<ol>
<li>校正规范<ol>
<li>临近度的度量</li>
<li>更常见</li>
</ol>
</li>
<li>编辑距离</li>
<li>K-gram 索引</li>
<li>上下文敏感：保留 文档集 高频组合</li>
</ol>
</li>
<li><p>基于发音：soundex 算法</p>
</li>
</ol>
<h2 id="Chapter-4-索引构建"><a href="#Chapter-4-索引构建" class="headerlink" title="Chapter 4 索引构建"></a>Chapter 4 索引构建</h2><ol>
<li>硬件基础：<ol>
<li>访问内存 快于 访问磁盘</li>
<li>磁盘读写 寻道时间</li>
<li>操作系统以数据块为单位进行读写</li>
<li>磁盘 I/O 由系统总线处理 而不是 处理器</li>
<li>IR 系统服务器 内存 &gt;&gt; 系统内存</li>
</ol>
</li>
<li>基于块排序索引构建算法<ol>
<li>目的：基于磁盘的外部排序算法：减少随机寻道次数</li>
<li>步骤：分割文档集 -&gt; 排序词项ID - 文档ID 对 -&gt; 将临时排序结果存放到磁盘 -&gt; 合并</li>
</ol>
</li>
<li>内存式扫描索引构建算法<ol>
<li>目的：消除 词项 -&gt; ID 的数据结构</li>
<li>原理：每个块采用新字典</li>
</ol>
</li>
<li>分布式索引构建<ol>
<li>往往按照词项或文档进行分割后分布在多台计算机上</li>
<li>MapReduce架构：面向大规模计算机集群<ol>
<li>将计算任务划分成子任务快</li>
<li>使得每个工作节点在短时间内能够快速处理</li>
</ol>
</li>
</ol>
</li>
<li>动态索引构建<ol>
<li>考虑文档集动态变化</li>
</ol>
</li>
</ol>
<h2 id="Chapter-5-索引压缩"><a href="#Chapter-5-索引压缩" class="headerlink" title="Chapter 5 索引压缩"></a>Chapter 5 索引压缩</h2><p><em>Key word：无损压缩 | 词典和倒排索引 | 高速缓存 | 加快传输 | 统计特性| 词典 -&gt; 长串| 按块存储压缩 |变长字节编码和 γ 编码</em></p>
<ol>
<li>无损压缩 | 有损压缩</li>
<li>Heaps 定律 -&gt; 估计词项数目<ul>
<li>文档集大小和词汇量之间在对数空间存在线性关系</li>
<li>两点假设：文档数目 ++ 词汇量++ 且不收敛；大规模文档集 词汇量 极大</li>
</ul>
</li>
<li>Zipf 定律 -&gt; 建模词项分布<ul>
<li>如果 t1 是文档集中的出现最多的词项，t2 是文档集中的出现第二多的词项，依此类推，那么，<br>排名第 i 多的词项的文档集频率 cfi与 1/i 成正比</li>
</ul>
</li>
<li>词典压缩<ul>
<li>目的：将词典放入内存</li>
<li>方法：<ul>
<li>将词典看作单一字符串 -&gt; 定长数组 -&gt; 指针</li>
<li>按块储存 -&gt; 保留第一个词项指针 额外字节保存词项长度 -&gt; 减少词项指针个数</li>
<li>前端编码 -&gt; 公共前缀</li>
<li>最小完美哈希 -&gt; 静态</li>
</ul>
</li>
<li><img src=".\信息检索导论\image3.png" alt="image3"></li>
</ul>
</li>
<li>倒排记录表压缩<ul>
<li>原理：高频词出现的文档 ID 序列值之间相差不大</li>
<li>可变字节码</li>
<li>γ 编码</li>
</ul>
</li>
</ol>
<h2 id="Chapter-6-文档评分、词项权重计算及向量空间模型"><a href="#Chapter-6-文档评分、词项权重计算及向量空间模型" class="headerlink" title="Chapter 6 文档评分、词项权重计算及向量空间模型"></a>Chapter 6 文档评分、词项权重计算及向量空间模型</h2><p><em>Key word：评分和排序 | 参数化索引和域索引 | 词项权重 | 向量空间法 | 向量空间法的变形</em></p>
<ol>
<li>结构信息，元数据（metadata），字段（field）</li>
<li>域加权评分 -&gt; 排序式布尔检索</li>
<li>权重学习</li>
</ol>
<h2 id="Chapter-7-一个完整搜索系统中的评分计算"><a href="#Chapter-7-一个完整搜索系统中的评分计算" class="headerlink" title="Chapter 7 一个完整搜索系统中的评分计算"></a>Chapter 7 一个完整搜索系统中的评分计算</h2><p><em>Key word：启发式策略 | 非精确排序 | 其他评分因子 | 部件 | 启发</em></p>
<ol>
<li>快速评分和排序<ul>
<li>考虑相对得分 而不是 绝对得分</li>
<li>筛除 idf 值较高的词项对应的倒排记录表</li>
<li>胜者表</li>
<li>静态得分和排序</li>
<li>影响度排序</li>
<li>簇剪枝</li>
</ul>
</li>
<li>信息检索系统组成<ul>
<li>层次型索引</li>
<li>查询词项的邻近性</li>
</ul>
</li>
<li>向量空间模型对查询操作的支持</li>
</ol>
<h2 id="Chapter-8-信息检索的评价"><a href="#Chapter-8-信息检索的评价" class="headerlink" title="Chapter 8 信息检索的评价"></a>Chapter 8 信息检索的评价</h2><p><em>Key word：评价指标 | 标准测试集 | 形式化评价方法 | 用户效用 | 其他质量检索结果度量的计数</em></p>
<ol>
<li>常规测试方法<ul>
<li>文档集，信息需求，相关性判定结果</li>
<li>二值</li>
</ul>
</li>
<li>标准测试集</li>
<li>无序检索结果集合评价<ul>
<li>正确率</li>
<li>召回率</li>
<li>平衡 F 值</li>
</ul>
</li>
<li>有序检索结果集合评价</li>
<li>相关性判定</li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>复变函数</title>
    <url>/2021/10/30/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Chapter-1-复数和复平面"><a href="#Chapter-1-复数和复平面" class="headerlink" title="Chapter 1 复数和复平面"></a>Chapter 1 复数和复平面</h2><span id="more"></span>
<h3 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h3><ol>
<li><p>复数域：实（虚）部 | 复数的代数结构 -&gt; 复数域 $\mathbb{C}$</p>
</li>
<li><p>$\mathbb{R}^2$ 复平面引入拓扑结构 -&gt; 欧式距离 | 构建双射 $\mathbb{C} \rightarrow \mathbb{R}^2$， 此时称为平面 $\mathbb{C}$</p>
</li>
<li><p>等价类：一向量经过平行移动关系得到的所有向量与原向量构成等价类</p>
</li>
<li><p>辅角 $Arg\ z = \theta + 2k\pi \ (k \in \mathbb{Z})$，辅角主值 $arg\ z = \theta \ (-\pi &lt; \theta &lt; \pi)$  </p>
</li>
<li><p>三角表达式： $z = |z|\ (\cos {Arg \ z}+i\sin{Arg\ z})$ | 共轭</p>
</li>
<li><p>三角不等式： $|z_1 + z_2| \leq |z_1|+|z_2| \qquad |z_1 - z_2| \geq ||z_1|-|z_2||$</p>
</li>
<li><p>重要不等式：$|Re\ z| \leq |z| \qquad |Im\ z| \leq |z|$ </p>
</li>
<li><p>重要等式：$|z| = \sqrt{z\overline{z}} \qquad x = \frac{z+\overline{z}}{2} \qquad y = \frac{z-\overline{z}}{i2}$</p>
</li>
<li><p>棣莫弗公式：$(\cos{\theta}+i\sin{\theta})^m = \cos{m\theta} + i\sin{m\theta}$</p>
<p>推导：$z^{\frac{1}{n}} = +\sqrt[n]{|z|}[\cos{\frac{1}{n}Arg\ z} + i\sin{\frac{1}{n}Arg \ z}]$</p>
</li>
<li><p>复球面和无穷大：$z \rightarrow (x’,y’,u’)$</p>
<script type="math/tex; mode=display">
x' = \frac{z+\overline{z}}{|z|^2+1} \qquad y' = \frac{z-\overline{z}}{i(|z|^2+1)} \qquad u' = \frac{|z|^2-1}{|z|^2+1}</script></li>
</ol>
<h3 id="Section-2"><a href="#Section-2" class="headerlink" title="Section 2"></a>Section 2</h3><ol>
<li>复平面的拓扑结构：距离 -&gt; 邻域 -&gt; 聚点、边界点 -&gt; 开集、闭集 -&gt; 紧集 </li>
<li>区域 &lt;- 连通性 若尔当曲线 &lt;- 简单闭合曲线</li>
<li>若尔当定理：若尔当闭合曲线可以将平面分成两个没有公共点的区域</li>
</ol>
]]></content>
      <categories>
        <category>Mathmetic</category>
      </categories>
      <tags>
        <tag>MA</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论和数理统计</title>
    <url>/2021/10/31/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>​    《概率论和数理统计》是高等院校理工类、经管类的重要课程之一。在考研数学中的比重大约占22%左右。主要内容包括：概率论的基本概念、<a href="https://baike.baidu.com/item/随机变量/828980">随机变量</a>及其<a href="https://baike.baidu.com/item/概率分布/828907">概率分布</a>、<a href="https://baike.baidu.com/item/数字特征/3402134">数字特征</a>、<a href="https://baike.baidu.com/item/大数定律/410082">大数定律</a>与<a href="https://baike.baidu.com/item/中心极限定理/829451">中心极限定理</a>、统计量及其概率分布、<a href="https://baike.baidu.com/item/参数估计/2224132">参数估计</a>和假设检验、回归分析、<a href="https://baike.baidu.com/item/方差分析/1502206">方差分析</a>、<a href="https://baike.baidu.com/item/马尔科夫链/4688932">马尔科夫链</a>等内容。</p>
<span id="more"></span>
<h2 id="Chapter-1-随机事件和概率"><a href="#Chapter-1-随机事件和概率" class="headerlink" title="Chapter 1 随机事件和概率"></a>Chapter 1 随机事件和概率</h2><ol>
<li><p>随机现象 </p>
<ul>
<li>随机性</li>
<li>偶然性</li>
<li>统计规律性</li>
</ul>
</li>
<li><p>随机试验</p>
</li>
<li><p>样本空间 $\Omega$  样本点 $\omega$</p>
</li>
<li><p>随机事件的关系和运算 -&gt; 集合</p>
</li>
<li><p>概率公理</p>
<ul>
<li>三条公理<ul>
<li>非负性</li>
<li>规范性</li>
<li>可列可加性</li>
</ul>
</li>
<li>统计意义<ul>
<li>频率 -&gt; 稳定值</li>
</ul>
</li>
</ul>
</li>
<li><p>古典概型 -&gt; 等可能概型</p>
</li>
<li><p>几何概型</p>
</li>
<li><p>条件概率</p>
<script type="math/tex; mode=display">
P(B|A) = \frac{P(AB)}{p(A)}</script><ul>
<li><p>满足概率公理系统 -&gt; 概率</p>
</li>
<li><p>乘法公式</p>
<script type="math/tex; mode=display">
P(AB) = P(A)P(B)</script></li>
</ul>
</li>
<li><p>全概率公式</p>
<ul>
<li>划分 -&gt; 并全交空</li>
<li>每个划分的条件概率相加</li>
</ul>
</li>
<li><p>Bayes 公式</p>
<script type="math/tex; mode=display">
P(B_i|A) = \frac{P(AB_i)}{P(A)} =\frac{P(B_i)P(A|B_i)}{\sum^n_{j=1}P(B_j)P(A|B_j)}</script></li>
<li><p>随机事件独立性</p>
<ul>
<li>$P(AB)=P(A)P(B) $</li>
<li>$P(A|B) = P(A) \qquad P(B|A) = P(B)$</li>
<li>相互独立|两两独立</li>
</ul>
</li>
</ol>
<h2 id="Chapter-2-随机变量及其分布"><a href="#Chapter-2-随机变量及其分布" class="headerlink" title="Chapter 2 随机变量及其分布"></a>Chapter 2 随机变量及其分布</h2><ol>
<li><p>随机变量 $X(w)$ -&gt; 量化</p>
</li>
<li><p>分布函数 $F(x) = P(X\leq x)$</p>
<ul>
<li>有界性，边界约束性</li>
<li>单调性</li>
<li>右连续性 $F(x+0) = F(x)$</li>
</ul>
</li>
<li><p>离散型随机变量 -&gt; 有限或可列无穷</p>
<ul>
<li>分布律</li>
<li>分布函数阶跃性</li>
</ul>
</li>
<li><p>常见的离散型随机变量</p>
<ul>
<li><p>0-1 分布</p>
<p>| X    | 0    | 1    |<br>| —— | —— | —— |<br>| P    | p    | 1-p  |</p>
<ul>
<li>$P(X=k)=p^k(1-p)^k$</li>
</ul>
</li>
<li><p>二项分布（伯努利分布）</p>
<ul>
<li>$X \sim B(n,p)$</li>
<li>$P(X=k)=C^k_np^k(1-p)^{n-k}$</li>
</ul>
</li>
<li><p>负二项分布（帕斯卡分布）</p>
<ul>
<li>$X\sim NB(r,p)$</li>
<li>$p(X=k)=C^{r-1}_{k-1}p^r(1-p)^{k-r}$</li>
<li>几何分布 $r \rarr 1$<ul>
<li>$P(X=k)=(1-p)^{k-1}p$</li>
</ul>
</li>
</ul>
</li>
<li><p>Poisson 分布</p>
<ul>
<li><p>泊松定理</p>
<p>假设 $\lim_{x\rarr+\infty}np_n=\lambda&gt;0$</p>
<script type="math/tex; mode=display">
\lim_{x\rarr+\infty}C^k_np^k_n(1-p_n)^{n-k}=e^{-\lambda}\frac{\lambda^k}{k!}</script></li>
<li><p>当随机事件以固定的平均瞬时速率随机且独立出现时，那么这个事件在一段时间内出现的次数服从泊松分布</p>
</li>
<li><p>参数为$(n，p)$的二项分布可以用参数 $\lambda=np$ 的泊松分布逼近</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>连续性随机变量及概率密度</p>
<ul>
<li>概率密度（非负性、规范性）</li>
<li>分布函数 $F(x)=\int_{-\infty}^xf(t)dt$</li>
</ul>
</li>
<li><p>常见的连续型随机变量</p>
<ul>
<li>均匀分布 $X\sim U(a,b)$</li>
<li>指数分布 $X \sim E(\lambda)$</li>
<li>正态分布 $X \sim N(\mu,\sigma)$</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Mathmetic</category>
      </categories>
      <tags>
        <tag>MA</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学</title>
    <url>/2021/10/30/%E6%8B%93%E6%89%91%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><span id="more"></span>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>一笔画问题和七桥问题</li>
<li>地图着色问题  -&gt; 问题与度量无关（距离，面积），而与区域邻接关系有关</li>
</ul>
<h3 id="Euler-多面体定理"><a href="#Euler-多面体定理" class="headerlink" title="Euler 多面体定理"></a>Euler 多面体定理</h3><p>凸多面体的面数 $f$ 、棱数 $l$ 和顶点数 $v$ 满足 Euler 公式<br>拓展：$f - l + v$ 由曲面本身决定，这个数称为 Euler 数</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>集合论</li>
<li>映射</li>
<li>笛卡尔积</li>
<li>等价关系</li>
</ul>
<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="拓扑空间"><a href="#拓扑空间" class="headerlink" title="拓扑空间"></a>拓扑空间</h3><ol>
<li><p>函数连续性的三种描述方法</p>
</li>
<li><p>拓扑空间的定义 -&gt; 拓扑公理：子集族 -&gt; i.全集和空集 ii.任意并 iii.有限交</p>
<blockquote>
<p>紧空间保证开集开性：任意并，有限交；保证闭集闭性：任意交，有限并</p>
</blockquote>
</li>
<li><p>离散拓扑和平凡拓扑</p>
</li>
<li><p>余有限拓扑、余可数拓扑和欧式拓扑</p>
</li>
</ol>
<h3 id="度量拓扑"><a href="#度量拓扑" class="headerlink" title="度量拓扑"></a>度量拓扑</h3><ol>
<li>度量空间 -&gt; 度量d -&gt; 正定性、对称性和三角不等式</li>
<li>赋范空间 -&gt; 范数 -&gt; 正定性、齐次性和三角不等式 -&gt; 线性空间 （线性性）-&gt; 线性赋范空间 </li>
<li>引理 -&gt; 任意两个球形领域的交集是若干球形邻域的并集<ul>
<li>考虑该交集合内所有点都是内点，满足两个球的内点性质，取小距离作为半径，该球完全位于集合内，得证</li>
</ul>
</li>
<li>命题：考虑子集族（若干球形邻域的并集）是 X 上的一个拓扑<ul>
<li>证明：公理(1)(2)显然，考虑公理(3)，由引理(7) 显然，得证</li>
<li>该子集族称为由度量 d 决定的度量拓扑</li>
</ul>
</li>
</ol>
<h3 id="拓扑空间基本概念"><a href="#拓扑空间基本概念" class="headerlink" title="拓扑空间基本概念"></a>拓扑空间基本概念</h3><ol>
<li>闭集 -&gt; 开集的余集<ul>
<li>全集和空集</li>
<li>任意交</li>
<li>有限并  -&gt; 由拓扑公理的 De morgan 定律推导</li>
</ul>
</li>
<li><p>邻域，内点，内部 </p>
<ul>
<li>$x \in A$  -&gt; x 是 A 的内点， A 是 x 的邻域， A 的所有内点为 A 的内部</li>
<li>A 是 B 子集 -&gt; A 的内部 是 B 的内部 的子集</li>
<li>A 等于 A 的内部 &lt;-&gt; A 是开集 </li>
</ul>
</li>
<li><p>聚点，闭包</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mathmetic</category>
      </categories>
      <tags>
        <tag>MA</tag>
      </tags>
  </entry>
</search>
