<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chengstones.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="仿cpp伪代码(Pseudocode)复现基本数据结构(DataStruct)">
<meta property="og:type" content="article">
<meta property="og:title" content="DataStruct-Pseudocode">
<meta property="og:url" content="https://chengstones.github.io/2021/11/02/DataStruct-Pseudocode/index.html">
<meta property="og:site_name" content="Autumn-Storage">
<meta property="og:description" content="仿cpp伪代码(Pseudocode)复现基本数据结构(DataStruct)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-02T01:03:39.000Z">
<meta property="article:modified_time" content="2021-11-18T06:05:28.616Z">
<meta property="article:author" content="Qiushi">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chengstones.github.io/2021/11/02/DataStruct-Pseudocode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>DataStruct-Pseudocode | Autumn-Storage</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Autumn-Storage" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Autumn-Storage</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">MySelf-Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chengstones.github.io/2021/11/02/DataStruct-Pseudocode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Qiushi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Autumn-Storage">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DataStruct-Pseudocode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-02 09:03:39" itemprop="dateCreated datePublished" datetime="2021-11-02T09:03:39+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-18 14:05:28" itemprop="dateModified" datetime="2021-11-18T14:05:28+08:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>仿cpp伪代码(Pseudocode)复现基本数据结构(DataStruct)<br><span id="more"></span></p>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表的基本运算</p>
<ul>
<li>建表 create()</li>
<li>清空 clear()</li>
<li>返回长度 length()</li>
<li>插入 insert(x, i)</li>
<li>删除 remove(i)</li>
<li>搜索 search(x)</li>
<li>访问 visit(i)</li>
<li>遍历 traverse()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;                    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">const</span> elemType &amp;x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> elemType &amp;x)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> elemType <span class="title">visit</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">list</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h3><ul>
<li>私有成员：当前长度 currentLength，数组大小 maxSize，数组头节点 data</li>
<li>私有函数：扩容数组 doubleSpace</li>
</ul>
<h4 id="扩容数组"><a href="#扩容数组" class="headerlink" title="扩容数组"></a>扩容数组</h4><ul>
<li>触发条件：当执行插入操作时，当前长度等于数组大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明临时数组保存数据;</span><br><span class="line">扩容;</span><br><span class="line">数组头节点 data 指向一个更大的数组;</span><br><span class="line"><span class="comment">// 挪动数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;currentLength;++i)&#123;</span><br><span class="line">    data[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">析构临时数组;</span><br></pre></td></tr></table></figure>
<h4 id="创建，返长，析构，清除，遍历"><a href="#创建，返长，析构，清除，遍历" class="headerlink" title="创建，返长，析构，清除，遍历"></a>创建，返长，析构，清除，遍历</h4><ul>
<li>创建申请一个定长的数组</li>
<li>返长直接返回当前长度</li>
<li>析构 delete []data</li>
<li>清除 使当前长度为 0</li>
<li>for 遍历</li>
</ul>
<h4 id="查找，访问"><a href="#查找，访问" class="headerlink" title="查找，访问"></a>查找，访问</h4><ul>
<li>遍历数组每一项，找到返回当前值，否则返回 -1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;currentLength;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(data[i] == 待查值) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接访问 data[i]</li>
</ul>
<h4 id="插入，清除"><a href="#插入，清除" class="headerlink" title="插入，清除"></a>插入，清除</h4><ul>
<li>插入采用逆序，从第 currentLength 开始， 每一项等于前一项</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(当前数组满了) 扩容;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(currentLength);j&gt;i;--j)&#123;</span><br><span class="line">    data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">data[i] = x;</span><br></pre></td></tr></table></figure>
<ul>
<li>清除采用正序，</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(i);j&lt;currentLength<span class="number">-1</span>;++j)&#123;</span><br><span class="line">    data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li>使用内置结构体 node，存有 data 和下一个 node 的指针</li>
<li>为了方便使用插入和清除操作，每个节点必须有前置节点，因此存在 head</li>
</ul>
<h5 id="创建，清除，析构，返长，遍历"><a href="#创建，清除，析构，返长，遍历" class="headerlink" title="创建，清除，析构，返长，遍历"></a>创建，清除，析构，返长，遍历</h5><ul>
<li>创建只需要声明头节点</li>
<li>清除从头节点的下一个节点开始，倘若该节点非空，则储存该节点析构，继续指向下一个节点<ul>
<li>最终头节点需要指向NULL</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node* p = head -&gt; next;</span><br><span class="line">node* delp;</span><br><span class="line">head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    delp = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> delp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>析构调用清空函数，析构头节点</li>
<li>返长从头节点开始，如果下一个节点非空，则长度加1</li>
<li>遍历，从头节点的下一个节点开始，若节点非空，输出值，指向后置节点，循环</li>
</ul>
<h5 id="查找，访问-1"><a href="#查找，访问-1" class="headerlink" title="查找，访问"></a>查找，访问</h5><ul>
<li>查找从头节点的下一个节点开始，若节点非空，比较待查值：若相同，则输出该位置，否则位置+1；最终输出-1（说明没找到）</li>
<li>访问从头节点的下一个节点开始，for 循环</li>
</ul>
<h5 id="插入，清除-1"><a href="#插入，清除-1" class="headerlink" title="插入，清除"></a>插入，清除</h5><ul>
<li>插入从头节点开始，跳跃次数等于位置，使指针的后置节点修改为以指针的后置节点为参数的节点</li>
<li>清除从头节点开始，跳跃次数等于位置，储存其后置节点作为临时节点析构，讲后置节点改为其后置节点的后置节点</li>
</ul>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h1 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的基本运算</p>
<ul>
<li>建树 create()</li>
<li>清空 clear()</li>
<li>判空 isEmpty()</li>
<li>找根结点 Root()</li>
<li>找父节点 parent(x)</li>
<li>找子节点 child(x,i)</li>
<li>剪枝 remove(x,i)</li>
<li>遍历 traverse()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Root</span><span class="params">(T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">parent</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">lchild</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">rchild</span><span class="params">(T x, T flag)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delLeft</span><span class="params">(T x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delRight</span><span class="params">(T x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3>二叉树的基本运算</li>
<li>建树 create()</li>
<li>清空 clear()</li>
<li>判空 isEmpty()</li>
<li>找根节点 root()</li>
<li>找父节点 parent(x)</li>
<li>找左右孩子 lchild(x), rchild(x)</li>
<li>删除左右子树 delLeft(x), delRight(x)</li>
<li>遍历 traverse()</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>私有函数，仿前序遍历</li>
<li>参数 x-&gt; 寻找值;</li>
<li>参数 node* t -&gt; 需要开始查找的子树根结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果查找树为空树， <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">如果自己就是查找值， <span class="keyword">return</span> 自己</span><br><span class="line">否则</span><br><span class="line">查找左子树，得到 tmp，若 tmp 非 <span class="literal">NULL</span>， <span class="keyword">return</span> tmp</span><br><span class="line">否则，一定返回右子树 <span class="keyword">return</span> t-&gt;right </span><br></pre></td></tr></table></figure>
<h4 id="清空，析构，剪枝"><a href="#清空，析构，剪枝" class="headerlink" title="清空，析构，剪枝"></a>清空，析构，剪枝</h4></li>
<li>仿前序遍历：剪枝左子树，剪枝右子树，析构自己<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有函数 clear 参数 node* </span></span><br><span class="line"><span class="keyword">if</span> (左子树非空) clear 左子树;</span><br><span class="line"><span class="keyword">if</span> (右子树非空) clear 右子树;</span><br><span class="line"><span class="keyword">delete</span> 自己 -&gt; node;</span><br><span class="line">自己 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口函数 clear， 析构函数</span></span><br><span class="line">clear 根节点</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝</span></span><br><span class="line"><span class="keyword">if</span> (左子树空) <span class="keyword">return</span>; <span class="comment">// if (右子树空) return;</span></span><br><span class="line">clear tmp -&gt; left;   <span class="comment">// clear tmp -&gt; right</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul>
<li>先访问根结点，再访问左右子树</li>
<li>具体实现 -&gt; 递归 -&gt; 传入参数结点，实现对应功能</li>
<li>接口函数 包装 参数 void <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口函数 参数 void</span></span><br><span class="line">前序遍历根结点;</span><br><span class="line"><span class="comment">// 私有函数 参数 node*</span></span><br><span class="line"><span class="keyword">if</span>(结点空) <span class="keyword">return</span>;</span><br><span class="line">访问 当前结点;</span><br><span class="line">前序遍历左子树;</span><br><span class="line">前序遍历右子树;</span><br><span class="line"><span class="comment">// 中序后序遍历的实现方法几乎相同</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul>
<li>队列</li>
<li>规则：出列头结点，访问该节点，将左右子节点入队</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">    tmp = que.<span class="built_in">dequeue</span>();</span><br><span class="line">    访问节点 tmp;</span><br><span class="line">    <span class="keyword">if</span>(tmp 有左节点) 左节点入队;</span><br><span class="line">    <span class="keyword">if</span>(tmp 有右节点) 右节点入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><ul>
<li>面向控制台，队列</li>
<li>参数 截止参数 flag</li>
<li>规则：出列头结点，向控制台申请左右子节点，若非截止结点，则生成节点并入队</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">生成根节点，根节点入队</span><br><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">    tmp = que.<span class="built_in">dequeue</span>();</span><br><span class="line">    控制台获得两个子树的输入;</span><br><span class="line">    <span class="keyword">if</span>(左输入非截止) 生成父节点链接的新节点，节点入队;</span><br><span class="line">    <span class="keyword">if</span>(右输入非截止) 生成父节点链接的新节点，节点入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="非递归前序"><a href="#非递归前序" class="headerlink" title="非递归前序"></a>非递归前序</h4><ul>
<li>栈；参数 void</li>
<li>规则：出栈顶，访问该节点，入栈右左节点</li>
<li>起始条件：入队根结点；终止条件：队列空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    访问该节点;</span><br><span class="line">    <span class="keyword">if</span>(该节点的右节点非空) 右节点入栈;</span><br><span class="line">    <span class="keyword">if</span>(该节点的左节点非空) 左节点入栈;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="非递归中序"><a href="#非递归中序" class="headerlink" title="非递归中序"></a>非递归中序</h4><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>抽象：访问 -&gt; 当访问子树只有一个节点时，即读取该数据；否则以相应规则继续 ‘访问’ 该子树</p>
<p>​    中序遍历相对于前序遍历，根节点不能直接访问，需要先访问它的左子树，然后才能访问根节点。假设以栈的方式储存任务节点，这里说明根节点需要出队两次才能被访问。第一次出栈后访问左节点，第二次出栈先访问自己，再访问右节点。</p>
<ul>
<li>新建结构体 StNode 封装之前的 Node 和出栈次数 TimesPop</li>
<li>规则：第一次出栈访问左子树，第二次出栈访问自己，访问右子树</li>
<li>起始条件：根节点入栈；终止条件：栈空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新节点 StNode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> Node*; TimesPop&#125;</span><br><span class="line"><span class="comment">// 中序遍历非递归实现</span></span><br><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(++current.TimesPop == <span class="number">1</span>)&#123;</span><br><span class="line">        当前节点重新入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有左子树) 左子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		访问该节点;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有右子树) 右子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归后序"><a href="#非递归后序" class="headerlink" title="非递归后序"></a>非递归后序</h4><h5 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h5><p>​    后序遍历在中序遍历的基础上继续展开，类比观察可知：后序遍历依次访问左子树，右子树和自己，因此考虑根节点第一次出栈后，将根节点入栈，再依次将右子树和左子树入栈即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新节点 StNode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> Node*; TimesPop&#125;</span><br><span class="line"><span class="comment">// 后序遍历非递归实现</span></span><br><span class="line">根节点入栈</span><br><span class="line"><span class="keyword">while</span>(栈非空)&#123;</span><br><span class="line">    current = s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(++current.TimesPop == <span class="number">1</span>)&#123;</span><br><span class="line">        当前节点重新入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有右子树) 右子树入栈;</span><br><span class="line">        <span class="keyword">if</span>(当前节点有左子树) 左子树入栈;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		访问该节点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与森林表示法"><a href="#树与森林表示法" class="headerlink" title="*树与森林表示法"></a>*树与森林表示法</h4><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="*哈夫曼树"></a>*哈夫曼树</h4><h5 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h5><ul>
<li>给定一个具有n个权值的节点的集合，构造出一片森林，其中每个森林都是只有树根节点的二叉树</li>
<li>执行 n-1 次循环操作，每个循环操作执行<ul>
<li>从当前森林选取权值最小和此最小的两棵树</li>
<li>以这两个数作为左右子树构建一棵新树，将新树的根节点加入森林</li>
<li>从原来的森林删除这两棵树</li>
</ul>
</li>
<li>由于创建树后这棵树不会被修改，因此可以采用静态方法：即在一开始为所有的数据声明空间</li>
</ul>
<h5 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h5><ul>
<li>初始化，申请 2n 数组，将数据储存在倒数n个空间内</li>
<li>循环 n-1 次，进行归并<ul>
<li>找到最小值，次小值及其对应位置</li>
<li>将最小值和次小值求和存入数组，将最小值和次小至位置存入左右子树，声明左右子树的父节点</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">申请 <span class="number">2</span>n 尺寸的大小;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size<span class="number">-1</span>);i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">    min1 = min2 = 极大值;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">j</span>(i+<span class="number">1</span>);j&lt;length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(该节点权重低于最小值)&#123;</span><br><span class="line">            替换最小值为该值;</span><br><span class="line">            替换次小值为最小值;</span><br><span class="line">            替换最小值位置为该值位置;</span><br><span class="line">            替换次小值位置为最小值位置；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(该节点权重低于次小值)&#123;</span><br><span class="line">            替换次小值为该值;</span><br><span class="line">            替换次小值位置为该值位置;</span><br><span class="line">        &#125;</span><br><span class="line">    	elem[i] = 最小值 + 次小值;</span><br><span class="line">        elem[i] 的左右子树 = 最小值位置，次小值位置;</span><br><span class="line">        elem[i].parent = <span class="number">0</span>;</span><br><span class="line">        elem[最小值位置].parent = 父节点位置 i;</span><br><span class="line">        elem[次小值位置].parent = 父节点位置 i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="导出哈夫曼编码"><a href="#导出哈夫曼编码" class="headerlink" title="导出哈夫曼编码"></a>导出哈夫曼编码</h5><ul>
<li>从每个叶子节点出发，返回寻找父节点：若其为左子树，则添加前缀’0‘，否则添加前缀’1‘</li>
<li>遍历每一个叶子节点，按对应数组位输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);i&lt;length;++i)&#123;</span><br><span class="line">    result[i-size].data = result[i].data;</span><br><span class="line">    result[i-size].code = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">    p = elem[i].parent; s = i;</span></span><br><span class="line"><span class="string">   	while(p 非0)&#123;</span></span><br><span class="line"><span class="string">        if(p的左节点是s)</span></span><br><span class="line"><span class="string">            result[i-size].code 添加前缀 &#x27;</span><span class="number">1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> 添加前缀 <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s = p;</span><br><span class="line">        p = elem[p].parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表达式树"><a href="#表达式树" class="headerlink" title="*表达式树"></a>*表达式树</h4><p>二叉树计算一个算术表达式由两个组成：i. 将中缀表达式转换成一个二叉树  ii. 对二叉树进行后序遍历</p>
<h5 id="构建表达式树"><a href="#构建表达式树" class="headerlink" title="构建表达式树"></a>构建表达式树</h5><h6 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h6><p>类比中缀表达式转换为后缀表达式的算法，我们考虑使用两个栈：操作符栈和子树栈。当操作符栈出栈时，选取子树栈顶的两个元素进行运算，返回结果加入操作数栈。</p>
<ul>
<li>按顺序读入表达式中的每个字符；<ul>
<li>若读入数字，则构造节点，压入子树栈</li>
<li>读入操作符，与栈顶优先级比较，依次出栈所有优先级高于该操作符的元素。然后将读入的操作符压栈</li>
<li>读入左括号，压栈；读入右括号，持续出栈直至到左括号</li>
<li>左括号优先级最高</li>
</ul>
</li>
<li>当操作符栈出栈时，依次由子树栈弹出两个子树，分别作为运算符栈的右左子树；</li>
<li>初始操作：将#压入操作符栈；终止操作：读完所有运算符后，将所有操作符出栈。最后将子树栈弹出，作为表达式树的根节点；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">将 # 入操作符栈;</span><br><span class="line"><span class="keyword">while</span>(!cin.<span class="built_in">get</span>(alpha))&#123;</span><br><span class="line">    <span class="keyword">if</span>(读入的字符是数字) 创建节点，将该节点压入子树栈;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(读入左括号) 压入操作符栈;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(读入右括号)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                操作符栈出栈，构造新的节点;</span><br><span class="line">                将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">                将节点压入子树栈;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(读入运算符)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">top</span>()优先级不低于运算符)&#123;</span><br><span class="line">                操作符栈出栈，构造新的节点;</span><br><span class="line">                将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">                将节点压入子树栈;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">	操作符栈出栈，构造新的节点;</span><br><span class="line">	将子树栈出栈两次，分别作为节点的右左子树;</span><br><span class="line">	将节点压入子树栈;</span><br><span class="line">&#125;</span><br><span class="line">返回子树栈顶，作为表达式树的根节点;</span><br></pre></td></tr></table></figure>
<h5 id="计算表达式树"><a href="#计算表达式树" class="headerlink" title="计算表达式树"></a>计算表达式树</h5><h6 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h6><p>仿后续遍历和后缀表达式计算方法，构造操作数栈</p>
<ul>
<li>按照后序遍历去访问表达式树的每个节点<ul>
<li>若节点是数字，则将其压入操作数栈</li>
<li>若节点是操作符，则对操作数栈进行两次出栈进行运算，将运算结果压栈</li>
</ul>
</li>
<li>初始操作：从根开始后序遍历；终止操作：遍历结束，弹出操作数栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(访问 == <span class="literal">NULL</span>) <span class="keyword">return</span></span><br><span class="line">访问左子树;</span><br><span class="line">访问右子树;</span><br><span class="line"><span class="keyword">if</span>(根节点是数字) 将数字压入操作数栈;</span><br><span class="line"><span class="keyword">else</span> 将操作数栈出栈两次，将运算结果压栈;</span><br></pre></td></tr></table></figure>
<h4 id="中序线索树"><a href="#中序线索树" class="headerlink" title="*中序线索树"></a>*中序线索树</h4><h5 id="建立中序线索树"><a href="#建立中序线索树" class="headerlink" title="建立中序线索树"></a>建立中序线索树</h5><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ul>
<li>从 First 节点开始，设置为 p</li>
<li>循环：访问 p 节点； 访问 p 节点的右子树：若是线索树，则p = 右子树，否则p = 右子树的 <em>左子树（\</em>左子树）</li>
<li>终止条件：右子树为 NULL</li>
</ul>
<h5 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h5><ul>
<li>从Root节点开始，设置为 p</li>
<li>循环：访问 p 节点；如果 p 节点有真左子树，设置 p 为其左子树。否则如果 p 节点有右子树，设置 p 为其真右子树。否则循环取 p 的后继线索，查看其是否存在右子树，如果有，则取p等于该右子树</li>
<li>终止条件：右子树是NULL</li>
</ul>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><ul>
<li>队列，数组，完全二叉树</li>
<li>顺序结构实现，根节点位于 1 处；k 节点的子节点为 2k，2k+1；k 节点的父节点为 k/2</li>
<li>入队，放在数组末尾；循环{与父节点比较，若父节点小，则依次向上取代}，停止条件{hole == 1；x &lt; array[hole/2]}，将 hole 处赋值新加入节点</li>
<li>出队，保存根节点值；将根节点值用数组末尾的值取代，再向下调节根节点处，保证堆的有序性</li>
</ul>
<h4 id="普通构造，析构，判空，返回首节点"><a href="#普通构造，析构，判空，返回首节点" class="headerlink" title="普通构造，析构，判空，返回首节点"></a>普通构造，析构，判空，返回首节点</h4><ul>
<li>普通构造函数申请新 array，初始化最大容量 maxSize，当前数量 currentSize</li>
<li>析构函数，析构 array 数组</li>
<li>返回 当前数量为0</li>
<li>返回 数组的第一个元素</li>
</ul>
<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ul>
<li>当堆满时（currentsize == maxSize - 1），翻倍容量</li>
<li>声明洞的位置，循环与父节点比较；停止条件{hole == 1；x &gt;= array[hole/2]}</li>
<li>将入队元素放置在洞的位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentSize == maxSize - <span class="number">1</span>) <span class="built_in">doubleSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hole = ++ currentSize;</span><br><span class="line"><span class="keyword">for</span>(;hole &gt; <span class="number">1</span>&amp;&amp; x &lt; array[hole/<span class="number">2</span>];hole/=<span class="number">2</span>)&#123;</span><br><span class="line">    array[hole] = array[hole/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = x;</span><br></pre></td></tr></table></figure>
<h4 id="出队和辅助函数-percolateDown"><a href="#出队和辅助函数-percolateDown" class="headerlink" title="出队和辅助函数 percolateDown"></a>出队和辅助函数 percolateDown</h4><h5 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h5><ul>
<li>percolate - 渗下</li>
<li>功能：当前节点的子树都保证有序性时，保证当前节点的有序性</li>
<li>取洞处的值，循环{找到最大的子树；比较洞与最大子树，若洞更大，交换子树与洞}；停止条件{没有子树；子树比洞更大}</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Type tmp = array[hole];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;hole*<span class="number">2</span>&lt;= currentSize;hole = child)&#123;</span><br><span class="line">    child = hole * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(右子树比左子树更小) ++child;</span><br><span class="line">    <span class="keyword">if</span>(更小的子树 &lt; tmp) array[hole] = array[child];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">array[hole] = tmp;</span><br></pre></td></tr></table></figure>
<h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保存头节点;</span><br><span class="line">头节点用数组末尾节点替代;</span><br><span class="line"><span class="built_in">percolateDown</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> 保存值;</span><br></pre></td></tr></table></figure>
<h4 id="新构造和辅助函数-buildHeap"><a href="#新构造和辅助函数-buildHeap" class="headerlink" title="新构造和辅助函数 buildHeap"></a>新构造和辅助函数 buildHeap</h4><h5 id="辅助函数-1"><a href="#辅助函数-1" class="headerlink" title="辅助函数"></a>辅助函数</h5><ul>
<li>buildHeap 构建堆</li>
<li>从下至上遍历所有有子树的节点，调用 percolateDown 函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(currentSize/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i))&#123;</span><br><span class="line">    <span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新构造"><a href="#新构造" class="headerlink" title="新构造"></a>新构造</h5><ul>
<li>初始化列表：最大容量(size + 10)，当前数量(size)</li>
<li>先构造一棵完全二叉树，再构建堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;size;++i)&#123;</span><br><span class="line">    array[i+<span class="number">1</span>] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">buildHeap</span>();</span><br></pre></td></tr></table></figure>
<h3 id="D堆"><a href="#D堆" class="headerlink" title="D堆"></a>D堆</h3><ul>
<li><p>每个节点有d个儿子，这样生成的堆比较矮</p>
</li>
<li><p>插入：O(logdN)</p>
</li>
<li><p>删除：需要在d个元素中找出最小的，时间复杂度为：O(dlogdN)</p>
</li>
<li><p>优点：插入快</p>
</li>
<li><p>缺点：删除慢</p>
</li>
<li><p>用途：</p>
<ul>
<li><p>插入比删除多的队列</p>
</li>
<li><p>队列太大，内存放不下，要放在外存的时候</p>
</li>
</ul>
</li>
</ul>
<h3 id="左堆"><a href="#左堆" class="headerlink" title="左堆"></a>左堆</h3><ul>
<li>空路径长度（NPL）<ul>
<li>Npl(x) 为 x 到不满两个子树的节点的最短路径。具有 0 个或 1 个子节点的节点的 npl 为0，npl（NULL） = -1</li>
</ul>
</li>
<li>左堆：左子树的 npl 大于等于 右子树的npl</li>
<li>特征：左堆是向左倾斜的堆</li>
</ul>
<h5 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h5><ul>
<li>将根节点值更大的堆 A 与另一个堆 B 的右子树归并，作为堆 B 的右子树</li>
<li>如果产生的新堆 右子树npl &gt; 左子树npl 则交换左右子树</li>
<li>递归终止条件：其中一个堆为空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node * <span class="title">merge</span><span class="params">(node* root1, node* root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="keyword">if</span>(root2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    root-&gt;val &lt; root2 -&gt; val ? (l = root1, r = root2) : (l = root2, r = root1);</span><br><span class="line">    </span><br><span class="line">    l -&gt; right = <span class="built_in">merge</span>(l-&gt;right,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l -&gt; left == <span class="literal">NULL</span> || l-&gt;right -&gt; npl &gt; l-&gt;left-&gt;npl)</span><br><span class="line">        <span class="built_in">swap</span>(l-&gt;right,l-&gt;left);</span><br><span class="line">    l-&gt;npl = l-&gt;left -&gt; npl + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合与静态查找"><a href="#集合与静态查找" class="headerlink" title="集合与静态查找"></a>集合与静态查找</h2><h3 id="数据类型-set"><a href="#数据类型-set" class="headerlink" title="数据类型 - set"></a>数据类型 - set</h3><ul>
<li>每个数据元素有个区别与其他元素的唯一标识符，称为关键字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY</span>, <span class="keyword">class</span> <span class="title">OTHER</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SET</span>&#123;</span></span><br><span class="line">	KEY key;</span><br><span class="line">    OTHER other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li>允许任何容器存储集合</li>
<li>常用的比如线性表和树</li>
<li>唯一仅适用于集合的存储的数据结构为散列表</li>
</ul>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><ul>
<li>用于查找的集合为查找表</li>
<li>分类<ul>
<li>静态查找表：数据相对稳定，鲜有变化（顺序存储）</li>
<li>动态查找表：有频繁的插入、删除操作（链式存储）</li>
<li>内部查找：一次性放入内存</li>
<li>外部查找：分批</li>
</ul>
</li>
</ul>
<h3 id="无序表的查找"><a href="#无序表的查找" class="headerlink" title="无序表的查找"></a>无序表的查找</h3><ul>
<li>线性的顺序查找</li>
<li>利用哨兵来减少比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置哨兵</span></span><br><span class="line">    data[<span class="number">0</span>].key = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);x!=data[i].key;--i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><ul>
<li>与无序表的顺序查找类似</li>
<li>不需要查找到表头</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大有序排列的有序表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 设置哨兵</span></span><br><span class="line">    data[<span class="number">0</span>].key = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">i</span>(size);x&lt;data[i].key;--i);</span><br><span class="line">    <span class="keyword">if</span>(x == data[i].key) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>双 flag：low，high</li>
<li>mid 由 low , high 二分生成，比较，根据大小改变 low, high</li>
<li>终止条件：x == data[mid].key or low &gt; high</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(SET data[], <span class="keyword">int</span> size, <span class="keyword">const</span> KEY &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">high</span><span class="params">(size)</span>,mid</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == data[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;data[mid].key) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul>
<li>线性插值</li>
<li>应用于分布均匀的情况</li>
</ul>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><ul>
<li>将数据集成打包成块</li>
<li>块间必须是有序的</li>
</ul>
<h2 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CS/" rel="tag"># CS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/31/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" rel="prev" title="概率论和数理统计">
      <i class="fa fa-chevron-left"></i> 概率论和数理统计
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/05/CSS/" rel="next" title="CSS">
      CSS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">顺序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">扩容数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%8C%E8%BF%94%E9%95%BF%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E9%81%8D%E5%8E%86"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">创建，返长，析构，清除，遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%8C%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">查找，访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%EF%BC%8C%E6%B8%85%E9%99%A4"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">插入，清除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E8%BF%94%E9%95%BF%EF%BC%8C%E9%81%8D%E5%8E%86"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">创建，清除，析构，返长，遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%8C%E8%AE%BF%E9%97%AE-1"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">查找，访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%EF%BC%8C%E6%B8%85%E9%99%A4-1"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">插入，清除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">循环链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">树状结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">2.1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E5%89%AA%E6%9E%9D"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">清空，析构，剪枝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E6%A0%91"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">建树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">非递归前序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">非递归中序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">2.1.1.7.1.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">非递归后序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%80%83-1"><span class="nav-number">2.1.1.8.1.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">*树与森林表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">*哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%80%83-2"><span class="nav-number">2.1.1.10.1.</span> <span class="nav-text">思考</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">2.1.1.10.2.</span> <span class="nav-text">构造哈夫曼树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">2.1.1.10.3.</span> <span class="nav-text">导出哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">2.1.1.11.</span> <span class="nav-text">*表达式树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">2.1.1.11.1.</span> <span class="nav-text">构建表达式树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%80%83-3"><span class="nav-number">2.1.1.11.1.1.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">2.1.1.11.2.</span> <span class="nav-text">计算表达式树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%9D%E8%80%83-4"><span class="nav-number">2.1.1.11.2.1.</span> <span class="nav-text">思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E6%A0%91"><span class="nav-number">2.1.1.12.</span> <span class="nav-text">*中序线索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E6%A0%91"><span class="nav-number">2.1.1.12.1.</span> <span class="nav-text">建立中序线索树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.1.12.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">2.1.1.12.3.</span> <span class="nav-text">前序遍历</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">优先级队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">二叉堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%9E%84%E9%80%A0%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E5%88%A4%E7%A9%BA%EF%BC%8C%E8%BF%94%E5%9B%9E%E9%A6%96%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">普通构造，析构，判空，返回首节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E9%98%9F"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E5%92%8C%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-percolateDown"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">出队和辅助函数 percolateDown</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.1.3.1.</span> <span class="nav-text">辅助函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9F"><span class="nav-number">2.2.1.3.2.</span> <span class="nav-text">出队</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E6%9E%84%E9%80%A0%E5%92%8C%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-buildHeap"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">新构造和辅助函数 buildHeap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-1"><span class="nav-number">2.2.1.4.1.</span> <span class="nav-text">辅助函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E6%9E%84%E9%80%A0"><span class="nav-number">2.2.1.4.2.</span> <span class="nav-text">新构造</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D%E5%A0%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">D堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%A0%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">左堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6"><span class="nav-number">2.2.3.0.1.</span> <span class="nav-text">归并</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.</span> <span class="nav-text">集合与静态查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-set"><span class="nav-number">2.3.1.</span> <span class="nav-text">数据类型 - set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.4.</span> <span class="nav-text">无序表的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.5.</span> <span class="nav-text">有序表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.5.4.</span> <span class="nav-text">分块查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.</span> <span class="nav-text">动态查找</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qiushi"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Qiushi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiushi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
